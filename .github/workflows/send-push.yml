# =============================================================================
# ECHOELMUSIC - APNs PUSH NOTIFICATION SENDER
# =============================================================================
# Sends push notifications to all registered devices via Apple APNs HTTP/2 API.
# Device tokens are stored in CloudKit public database.
#
# Usage:
#   - Manually trigger from GitHub Actions UI
#   - Auto-trigger on new release tag
#   - Provide title, body, category, and optional deep link
#
# Requires secrets:
#   - APNS_KEY_ID: Apple APNs Key ID
#   - APNS_KEY_CONTENT: Contents of the .p8 key file
#   - APP_STORE_CONNECT_ISSUER_ID: Apple Team ID (used as APNs team ID)
# =============================================================================

name: "Send Push Notification"

on:
  workflow_dispatch:
    inputs:
      title:
        description: 'Notification title'
        required: true
        type: string
      body:
        description: 'Notification body text'
        required: true
        type: string
      category:
        description: 'Notification category'
        required: true
        default: 'ECHOEL_APP_UPDATE'
        type: choice
        options:
          - ECHOEL_APP_UPDATE
          - ECHOEL_FEATURE
          - ECHOEL_WELLNESS
          - ECHOEL_SESSION
          - ECHOEL_BIO_ALERT
          - ECHOEL_COMMUNITY
      environment:
        description: 'APNs environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - development
      badge_count:
        description: 'Badge count (0 to clear)'
        required: false
        default: '1'
        type: string
      deep_link:
        description: 'Deep link path (e.g. /wellness, /session, /update)'
        required: false
        type: string
      device_tokens:
        description: 'Comma-separated device tokens (leave empty for all devices via CloudKit)'
        required: false
        type: string

  # Auto-send on new release
  release:
    types: [published]

env:
  BUNDLE_ID: com.echoelmusic.app

jobs:
  send-notification:
    name: "Send APNs Push"
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: "Checkout"
        uses: actions/checkout@v4

      - name: "Setup Python"
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: "Install dependencies"
        run: pip install PyJWT cryptography requests

      - name: "Determine notification content"
        id: content
        run: |
          if [ "${{ github.event_name }}" = "release" ]; then
            TITLE="Echoelmusic Update Available"
            BODY="${{ github.event.release.name }} â€” ${{ github.event.release.body }}"
            # Truncate body to 200 chars for push
            BODY="${BODY:0:200}"
            CATEGORY="ECHOEL_APP_UPDATE"
            ENVIRONMENT="production"
            BADGE="1"
            DEEP_LINK="/update"
          else
            TITLE="${{ inputs.title }}"
            BODY="${{ inputs.body }}"
            CATEGORY="${{ inputs.category }}"
            ENVIRONMENT="${{ inputs.environment }}"
            BADGE="${{ inputs.badge_count }}"
            DEEP_LINK="${{ inputs.deep_link }}"
          fi

          echo "title=${TITLE}" >> "$GITHUB_OUTPUT"
          echo "body=${BODY}" >> "$GITHUB_OUTPUT"
          echo "category=${CATEGORY}" >> "$GITHUB_OUTPUT"
          echo "environment=${ENVIRONMENT}" >> "$GITHUB_OUTPUT"
          echo "badge=${BADGE}" >> "$GITHUB_OUTPUT"
          echo "deep_link=${DEEP_LINK}" >> "$GITHUB_OUTPUT"

      - name: "Write APNs key"
        env:
          APNS_KEY_CONTENT: ${{ secrets.APNS_KEY_CONTENT }}
          APNS_KEY_ID: ${{ secrets.APNS_KEY_ID }}
        run: |
          mkdir -p /tmp/apns
          echo "$APNS_KEY_CONTENT" > /tmp/apns/AuthKey_${APNS_KEY_ID}.p8
          chmod 600 /tmp/apns/AuthKey_${APNS_KEY_ID}.p8

      - name: "Send push notifications"
        env:
          APNS_KEY_ID: ${{ secrets.APNS_KEY_ID }}
          APNS_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          TITLE: ${{ steps.content.outputs.title }}
          BODY: ${{ steps.content.outputs.body }}
          CATEGORY: ${{ steps.content.outputs.category }}
          ENVIRONMENT: ${{ steps.content.outputs.environment }}
          BADGE: ${{ steps.content.outputs.badge }}
          DEEP_LINK: ${{ steps.content.outputs.deep_link }}
          DEVICE_TOKENS: ${{ inputs.device_tokens }}
        run: |
          python3 << 'PYTHON_SCRIPT'
          import jwt
          import time
          import json
          import http.client
          import os
          import sys

          # --- Config ---
          key_id = os.environ["APNS_KEY_ID"]
          team_id = os.environ["APNS_TEAM_ID"]
          bundle_id = "com.echoelmusic.app"
          environment = os.environ.get("ENVIRONMENT", "production")
          title = os.environ.get("TITLE", "Echoelmusic")
          body = os.environ.get("BODY", "")
          category = os.environ.get("CATEGORY", "ECHOEL_APP_UPDATE")
          badge = int(os.environ.get("BADGE", "1"))
          deep_link = os.environ.get("DEEP_LINK", "")
          manual_tokens = os.environ.get("DEVICE_TOKENS", "").strip()

          # --- APNs host ---
          if environment == "production":
              apns_host = "api.push.apple.com"
          else:
              apns_host = "api.sandbox.push.apple.com"

          # --- Read .p8 key ---
          key_path = f"/tmp/apns/AuthKey_{key_id}.p8"
          with open(key_path, "r") as f:
              private_key = f.read()

          # --- Generate JWT ---
          token_payload = {
              "iss": team_id,
              "iat": int(time.time())
          }
          headers = {
              "alg": "ES256",
              "kid": key_id
          }
          auth_token = jwt.encode(token_payload, private_key, algorithm="ES256", headers=headers)

          # --- Build APNs payload ---
          payload = {
              "aps": {
                  "alert": {
                      "title": title,
                      "body": body
                  },
                  "badge": badge,
                  "sound": "default",
                  "category": category,
                  "mutable-content": 1,
                  "content-available": 1
              }
          }

          if deep_link:
              payload["deepLink"] = deep_link

          payload_json = json.dumps(payload)

          # --- Get device tokens ---
          if manual_tokens:
              tokens = [t.strip() for t in manual_tokens.split(",") if t.strip()]
              print(f"Using {len(tokens)} manually provided token(s)")
          else:
              # Read tokens from a file if available, otherwise log instruction
              token_file = ".github/device_tokens.txt"
              if os.path.exists(token_file):
                  with open(token_file, "r") as f:
                      tokens = [line.strip() for line in f if line.strip() and not line.startswith("#")]
                  print(f"Loaded {len(tokens)} token(s) from {token_file}")
              else:
                  print("No device tokens available.")
                  print("Provide tokens via:")
                  print("  1. workflow_dispatch 'device_tokens' input")
                  print("  2. .github/device_tokens.txt file")
                  print("  3. CloudKit export (run the export script first)")
                  print("")
                  print("To export from CloudKit, use:")
                  print("  swift run EchoelPushExport > .github/device_tokens.txt")
                  sys.exit(0)

          if not tokens:
              print("No tokens to send to. Exiting.")
              sys.exit(0)

          # --- Send to each device ---
          success_count = 0
          fail_count = 0

          conn = http.client.HTTPSConnection(apns_host, 443)

          for token in tokens:
              apns_headers = {
                  "authorization": f"bearer {auth_token}",
                  "apns-topic": bundle_id,
                  "apns-push-type": "alert",
                  "apns-priority": "10",
                  "apns-expiration": "0",
                  "content-type": "application/json"
              }

              path = f"/3/device/{token}"
              conn.request("POST", path, body=payload_json, headers=apns_headers)
              response = conn.getresponse()
              response_body = response.read().decode("utf-8")

              if response.status == 200:
                  success_count += 1
                  print(f"  OK: {token[:16]}...")
              else:
                  fail_count += 1
                  print(f"  FAIL ({response.status}): {token[:16]}... - {response_body}")

          conn.close()

          print(f"\nDone: {success_count} sent, {fail_count} failed, {len(tokens)} total")

          if fail_count > 0 and success_count == 0:
              sys.exit(1)
          PYTHON_SCRIPT

      - name: "Cleanup"
        if: always()
        run: rm -rf /tmp/apns

      - name: "Summary"
        run: |
          echo "## Push Notification Sent" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "| Field | Value |" >> "$GITHUB_STEP_SUMMARY"
          echo "|-------|-------|" >> "$GITHUB_STEP_SUMMARY"
          echo "| Title | ${{ steps.content.outputs.title }} |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Body | ${{ steps.content.outputs.body }} |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Category | ${{ steps.content.outputs.category }} |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Environment | ${{ steps.content.outputs.environment }} |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Deep Link | ${{ steps.content.outputs.deep_link }} |" >> "$GITHUB_STEP_SUMMARY"
