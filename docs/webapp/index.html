<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Echoelmusic WebApp - Bio-Reactive Sound Experience</title>
    <meta name="description" content="Experience Echoelmusic in your browser. Bio-reactive synthesizer with real-time visualizations.">
    <meta name="theme-color" content="#FF1494">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" href="manifest.json">
    <style>
        :root {
            --pink: #FF1494;
            --cyan: #00FFFF;
            --purple: #9933FF;
            --lavender: #CC99FF;
            --coral: #FF7F66;
            --deep-black: #050510;
            --midnight: #0D0D26;
            --dark-purple: #1A0D33;
            --glass-bg: rgba(255,255,255,0.06);
            --glass-border: rgba(255,255,255,0.12);
            --text-primary: #ffffff;
            --text-secondary: rgba(255,255,255,0.85);
            --text-muted: rgba(255,255,255,0.5);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
            background: linear-gradient(135deg, var(--deep-black) 0%, var(--midnight) 50%, var(--dark-purple) 100%);
            color: var(--text-primary);
            -webkit-font-smoothing: antialiased;
        }

        /* ==================== CANVAS LAYERS ==================== */

        #visualizer-canvas {
            position: fixed;
            inset: 0;
            z-index: 0;
        }

        /* ==================== UI OVERLAY ==================== */

        .ui-overlay {
            position: fixed;
            inset: 0;
            z-index: 10;
            display: grid;
            grid-template-rows: auto 1fr auto;
            pointer-events: none;
        }

        .ui-overlay > * {
            pointer-events: auto;
        }

        /* Header */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 24px;
            background: linear-gradient(180deg, rgba(0,0,0,0.6) 0%, transparent 100%);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 18px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        .logo svg { width: 36px; height: 36px; }

        .logo span {
            background: linear-gradient(135deg, var(--pink), var(--purple), var(--cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Bio Panel */
        .bio-panel {
            display: flex;
            gap: 16px;
        }

        .bio-metric {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 16px;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            backdrop-filter: blur(20px);
            min-width: 80px;
        }

        .bio-metric .value {
            font-size: 24px;
            font-weight: 300;
            font-variant-numeric: tabular-nums;
        }

        .bio-metric .label {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
            margin-top: 2px;
        }

        .bio-metric.heart .value { color: var(--pink); text-shadow: 0 0 20px rgba(255,20,148,0.5); }
        .bio-metric.hrv .value { color: var(--cyan); text-shadow: 0 0 20px rgba(0,255,255,0.5); }
        .bio-metric.coherence .value { color: var(--purple); text-shadow: 0 0 20px rgba(153,51,255,0.5); }

        /* Main Area - Touch Pad */
        .main-area {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 24px;
            pointer-events: none;
        }

        .touch-pad {
            width: min(500px, 90vw);
            height: min(500px, 50vh);
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            backdrop-filter: blur(30px);
            position: relative;
            overflow: hidden;
            cursor: crosshair;
            pointer-events: auto;
            touch-action: none;
        }

        .touch-pad::before {
            content: '';
            position: absolute;
            inset: 0;
            background:
                linear-gradient(90deg, transparent 49.5%, rgba(255,255,255,0.03) 49.5%, rgba(255,255,255,0.03) 50.5%, transparent 50.5%),
                linear-gradient(0deg, transparent 49.5%, rgba(255,255,255,0.03) 49.5%, rgba(255,255,255,0.03) 50.5%, transparent 50.5%);
            pointer-events: none;
        }

        .touch-indicator {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 2px solid var(--cyan);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: 0 0 30px rgba(0,255,255,0.5), inset 0 0 20px rgba(0,255,255,0.2);
        }

        .touch-indicator.active {
            opacity: 1;
            animation: touchPulse 0.5s ease-out;
        }

        @keyframes touchPulse {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .touch-label {
            position: absolute;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-muted);
        }

        .touch-label.x-label { bottom: 12px; left: 50%; transform: translateX(-50%); }
        .touch-label.y-label { left: 12px; top: 50%; transform: translateY(-50%) rotate(-90deg); }

        /* Control Bar */
        .control-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 16px;
            padding: 20px 24px 32px;
            background: linear-gradient(0deg, rgba(0,0,0,0.6) 0%, transparent 100%);
            flex-wrap: wrap;
        }

        /* Waveform Selector */
        .waveform-selector {
            display: flex;
            gap: 8px;
        }

        .wave-btn {
            width: 48px;
            height: 48px;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .wave-btn:hover {
            background: rgba(255,255,255,0.1);
            border-color: var(--pink);
        }

        .wave-btn.active {
            background: linear-gradient(135deg, rgba(255,20,148,0.2), rgba(153,51,255,0.2));
            border-color: var(--pink);
            color: var(--pink);
            box-shadow: 0 0 20px rgba(255,20,148,0.3);
        }

        .wave-btn svg { width: 24px; height: 24px; }

        /* Effect Knobs */
        .effect-controls {
            display: flex;
            gap: 24px;
        }

        .knob-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .knob {
            width: 56px;
            height: 56px;
            background: conic-gradient(from 135deg, var(--glass-bg) 0deg, var(--cyan) calc(var(--value, 0.5) * 270deg), var(--glass-bg) calc(var(--value, 0.5) * 270deg));
            border: 2px solid var(--glass-border);
            border-radius: 50%;
            position: relative;
            cursor: pointer;
        }

        .knob::after {
            content: '';
            position: absolute;
            top: 8px;
            left: 50%;
            width: 3px;
            height: 12px;
            background: var(--text-primary);
            border-radius: 2px;
            transform-origin: center 20px;
            transform: translateX(-50%) rotate(calc((var(--value, 0.5) * 270deg) - 135deg));
        }

        .knob-label {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
        }

        /* Visualizer Mode Selector */
        .viz-selector {
            display: flex;
            gap: 8px;
        }

        .viz-btn {
            padding: 10px 16px;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            color: var(--text-muted);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .viz-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .viz-btn.active {
            background: linear-gradient(135deg, rgba(0,255,255,0.2), rgba(153,51,255,0.2));
            border-color: var(--cyan);
            color: var(--cyan);
        }

        /* Status Indicator */
        .status {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            font-size: 11px;
            color: var(--text-muted);
            backdrop-filter: blur(20px);
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
        }

        .status.visible { opacity: 1; }

        /* Start Overlay */
        .start-overlay {
            position: fixed;
            inset: 0;
            background: rgba(5,5,16,0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s, visibility 0.5s;
        }

        .start-overlay.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .start-overlay h1 {
            font-size: clamp(32px, 8vw, 56px);
            font-weight: 700;
            margin-bottom: 16px;
            background: linear-gradient(135deg, var(--pink), var(--purple), var(--cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .start-overlay p {
            color: var(--text-muted);
            margin-bottom: 32px;
            font-size: 16px;
        }

        .start-btn {
            padding: 18px 48px;
            background: linear-gradient(135deg, var(--pink), var(--purple));
            border: none;
            border-radius: 30px;
            color: white;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 40px rgba(255,20,148,0.4);
        }

        .start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 60px rgba(255,20,148,0.6);
        }

        /* Responsive */
        @media (max-width: 600px) {
            .bio-panel { gap: 8px; }
            .bio-metric { padding: 6px 10px; min-width: 60px; }
            .bio-metric .value { font-size: 18px; }
            .effect-controls { gap: 16px; }
            .knob { width: 44px; height: 44px; }
            .control-bar { gap: 12px; padding: 16px 16px 24px; }
        }

        /* Accessibility */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                transition-duration: 0.01ms !important;
            }
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }
    </style>
</head>
<body>
    <!-- Start Overlay -->
    <div class="start-overlay" id="startOverlay">
        <h1>Echoelmusic</h1>
        <p>Bio-Reactive Sound Experience</p>
        <button class="start-btn" id="startBtn">Start Experience</button>
    </div>

    <!-- Visualizer Canvas -->
    <canvas id="visualizer-canvas"></canvas>

    <!-- UI Overlay -->
    <div class="ui-overlay">
        <!-- Header -->
        <header>
            <div class="logo">
                <svg viewBox="0 0 512 512" fill="none">
                    <rect width="512" height="512" rx="115" fill="#000"/>
                    <ellipse cx="256" cy="256" rx="120" ry="50" stroke="#00FFFF" stroke-width="3" fill="none" opacity="0.6" transform="rotate(-30 256 256)"/>
                    <ellipse cx="256" cy="256" rx="120" ry="50" stroke="#FF1494" stroke-width="3" fill="none" opacity="0.6" transform="rotate(30 256 256)"/>
                    <ellipse cx="256" cy="256" rx="120" ry="50" stroke="#9933FF" stroke-width="3" fill="none" opacity="0.6" transform="rotate(90 256 256)"/>
                    <circle cx="256" cy="256" r="40" fill="#FF1494"/>
                    <circle cx="256" cy="256" r="28" fill="#fff"/>
                </svg>
                <span>Echoelmusic</span>
            </div>

            <!-- Bio Metrics -->
            <div class="bio-panel">
                <div class="bio-metric heart">
                    <div class="value" id="heartValue">72</div>
                    <div class="label">BPM</div>
                </div>
                <div class="bio-metric hrv">
                    <div class="value" id="hrvValue">45</div>
                    <div class="label">HRV</div>
                </div>
                <div class="bio-metric coherence">
                    <div class="value" id="coherenceValue">0.65</div>
                    <div class="label">Coherence</div>
                </div>
            </div>
        </header>

        <!-- Main Touch Area -->
        <div class="main-area">
            <div class="touch-pad" id="touchPad" role="application" aria-label="XY Pad synthesizer control">
                <div class="touch-indicator" id="touchIndicator"></div>
                <span class="touch-label x-label">Pitch</span>
                <span class="touch-label y-label">Filter</span>
            </div>
        </div>

        <!-- Control Bar -->
        <div class="control-bar">
            <!-- Waveform Selector -->
            <div class="waveform-selector" role="radiogroup" aria-label="Waveform selection">
                <button class="wave-btn active" data-wave="sine" aria-label="Sine wave" title="Sine">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M2 12c2-4 4-4 6 0s4 4 6 0 4-4 6 0 4 4 6 0"/>
                    </svg>
                </button>
                <button class="wave-btn" data-wave="triangle" aria-label="Triangle wave" title="Triangle">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M2 12l4-6 4 12 4-12 4 12 4-6"/>
                    </svg>
                </button>
                <button class="wave-btn" data-wave="sawtooth" aria-label="Sawtooth wave" title="Sawtooth">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M2 18l6-12v12l6-12v12l6-12v12"/>
                    </svg>
                </button>
                <button class="wave-btn" data-wave="square" aria-label="Square wave" title="Square">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M2 18h4v-12h4v12h4v-12h4v12h4"/>
                    </svg>
                </button>
            </div>

            <!-- Effect Knobs -->
            <div class="effect-controls">
                <div class="knob-container">
                    <div class="knob" id="reverbKnob" data-param="reverb" style="--value: 0.3" role="slider" aria-label="Reverb" aria-valuemin="0" aria-valuemax="100" aria-valuenow="30"></div>
                    <span class="knob-label">Reverb</span>
                </div>
                <div class="knob-container">
                    <div class="knob" id="delayKnob" data-param="delay" style="--value: 0.2" role="slider" aria-label="Delay" aria-valuemin="0" aria-valuemax="100" aria-valuenow="20"></div>
                    <span class="knob-label">Delay</span>
                </div>
                <div class="knob-container">
                    <div class="knob" id="distortKnob" data-param="distort" style="--value: 0" role="slider" aria-label="Distortion" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0"></div>
                    <span class="knob-label">Drive</span>
                </div>
            </div>

            <!-- Visualizer Mode -->
            <div class="viz-selector" role="radiogroup" aria-label="Visualizer mode">
                <button class="viz-btn active" data-viz="spectrum">Spectrum</button>
                <button class="viz-btn" data-viz="waveform">Waveform</button>
                <button class="viz-btn" data-viz="sacred">Sacred</button>
            </div>
        </div>
    </div>

    <!-- Status -->
    <div class="status" id="status"></div>

    <script>
    // ==================== AUDIO ENGINE ====================
    class AudioEngine {
        constructor() {
            this.ctx = null;
            this.masterGain = null;
            this.filter = null;
            this.reverb = null;
            this.delay = null;
            this.distortion = null;
            this.analyser = null;
            this.oscillator = null;
            this.isPlaying = false;
            this.waveform = 'sine';
            this.params = {
                reverb: 0.3,
                delay: 0.2,
                distort: 0
            };
        }

        async init() {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();

            // Create nodes
            this.masterGain = this.ctx.createGain();
            this.masterGain.gain.value = 0.5;

            this.filter = this.ctx.createBiquadFilter();
            this.filter.type = 'lowpass';
            this.filter.frequency.value = 2000;
            this.filter.Q.value = 5;

            this.analyser = this.ctx.createAnalyser();
            this.analyser.fftSize = 2048;

            // Reverb (convolver with generated impulse)
            this.reverb = this.ctx.createConvolver();
            this.reverb.buffer = this.createReverbImpulse(2, 2);
            this.reverbGain = this.ctx.createGain();
            this.reverbGain.gain.value = this.params.reverb;

            // Delay
            this.delay = this.ctx.createDelay(1);
            this.delay.delayTime.value = 0.3;
            this.delayFeedback = this.ctx.createGain();
            this.delayFeedback.gain.value = 0.4;
            this.delayGain = this.ctx.createGain();
            this.delayGain.gain.value = this.params.delay;

            // Distortion
            this.distortion = this.ctx.createWaveShaper();
            this.distortion.curve = this.makeDistortionCurve(0);

            // Dry path
            this.dryGain = this.ctx.createGain();
            this.dryGain.gain.value = 1;

            // Connect nodes
            // Main path: filter -> distortion -> dry -> master
            this.filter.connect(this.distortion);
            this.distortion.connect(this.dryGain);
            this.dryGain.connect(this.masterGain);

            // Reverb send
            this.filter.connect(this.reverb);
            this.reverb.connect(this.reverbGain);
            this.reverbGain.connect(this.masterGain);

            // Delay send with feedback
            this.filter.connect(this.delay);
            this.delay.connect(this.delayFeedback);
            this.delayFeedback.connect(this.delay);
            this.delay.connect(this.delayGain);
            this.delayGain.connect(this.masterGain);

            // Master -> analyser -> output
            this.masterGain.connect(this.analyser);
            this.analyser.connect(this.ctx.destination);
        }

        createReverbImpulse(duration, decay) {
            const length = this.ctx.sampleRate * duration;
            const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
            for (let channel = 0; channel < 2; channel++) {
                const data = impulse.getChannelData(channel);
                for (let i = 0; i < length; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
                }
            }
            return impulse;
        }

        makeDistortionCurve(amount) {
            const samples = 44100;
            const curve = new Float32Array(samples);
            const deg = Math.PI / 180;
            for (let i = 0; i < samples; i++) {
                const x = (i * 2) / samples - 1;
                curve[i] = ((3 + amount * 100) * x * 20 * deg) / (Math.PI + amount * 100 * Math.abs(x));
            }
            return curve;
        }

        startNote(frequency) {
            if (this.oscillator) {
                this.oscillator.stop();
                this.oscillator.disconnect();
            }

            this.oscillator = this.ctx.createOscillator();
            this.oscillator.type = this.waveform;
            this.oscillator.frequency.setValueAtTime(frequency, this.ctx.currentTime);

            const envelope = this.ctx.createGain();
            envelope.gain.setValueAtTime(0, this.ctx.currentTime);
            envelope.gain.linearRampToValueAtTime(0.8, this.ctx.currentTime + 0.01);

            this.oscillator.connect(envelope);
            envelope.connect(this.filter);
            this.oscillator.start();
            this.isPlaying = true;
            this.currentEnvelope = envelope;
        }

        updateNote(frequency, filterValue) {
            if (this.oscillator && this.isPlaying) {
                this.oscillator.frequency.setTargetAtTime(frequency, this.ctx.currentTime, 0.01);
            }
            this.filter.frequency.setTargetAtTime(200 + filterValue * 8000, this.ctx.currentTime, 0.01);
        }

        stopNote() {
            if (this.currentEnvelope) {
                this.currentEnvelope.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.1);
            }
            this.isPlaying = false;
        }

        setWaveform(type) {
            this.waveform = type;
            if (this.oscillator) {
                this.oscillator.type = type;
            }
        }

        setParam(param, value) {
            this.params[param] = value;
            switch (param) {
                case 'reverb':
                    this.reverbGain.gain.setTargetAtTime(value, this.ctx.currentTime, 0.1);
                    break;
                case 'delay':
                    this.delayGain.gain.setTargetAtTime(value, this.ctx.currentTime, 0.1);
                    break;
                case 'distort':
                    this.distortion.curve = this.makeDistortionCurve(value);
                    break;
            }
        }

        getAnalyserData() {
            const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
            this.analyser.getByteFrequencyData(dataArray);
            return dataArray;
        }

        getWaveformData() {
            const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
            this.analyser.getByteTimeDomainData(dataArray);
            return dataArray;
        }
    }

    // ==================== BIO SIMULATOR ====================
    class BioSimulator {
        constructor() {
            this.heartRate = 72;
            this.hrv = 45;
            this.coherence = 0.65;
            this.breathPhase = 0;
            this.callbacks = [];
        }

        start() {
            this.interval = setInterval(() => this.update(), 100);
        }

        update() {
            // Simulate breathing cycle (6 breaths/min = 10s cycle)
            this.breathPhase = (this.breathPhase + 0.01) % 1;
            const breathInfluence = Math.sin(this.breathPhase * Math.PI * 2);

            // Heart rate varies with breath (RSA)
            this.heartRate = Math.round(72 + breathInfluence * 8 + (Math.random() - 0.5) * 4);

            // HRV varies naturally
            this.hrv = Math.round(45 + breathInfluence * 10 + (Math.random() - 0.5) * 5);

            // Coherence based on HRV stability
            const coherenceTarget = 0.5 + Math.abs(breathInfluence) * 0.3;
            this.coherence = this.coherence * 0.95 + coherenceTarget * 0.05;
            this.coherence = Math.round(this.coherence * 100) / 100;

            this.callbacks.forEach(cb => cb({
                heartRate: this.heartRate,
                hrv: this.hrv,
                coherence: this.coherence,
                breathPhase: this.breathPhase
            }));
        }

        onUpdate(callback) {
            this.callbacks.push(callback);
        }
    }

    // ==================== VISUALIZER ====================
    class Visualizer {
        constructor(canvas) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.mode = 'spectrum';
            this.bioData = { coherence: 0.5 };
            this.resize();
            window.addEventListener('resize', () => this.resize());
        }

        resize() {
            this.canvas.width = window.innerWidth * window.devicePixelRatio;
            this.canvas.height = window.innerHeight * window.devicePixelRatio;
            this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            this.width = window.innerWidth;
            this.height = window.innerHeight;
        }

        setBioData(data) {
            this.bioData = data;
        }

        draw(audioData, waveformData) {
            this.ctx.fillStyle = 'rgba(5, 5, 16, 0.15)';
            this.ctx.fillRect(0, 0, this.width, this.height);

            switch (this.mode) {
                case 'spectrum':
                    this.drawSpectrum(audioData);
                    break;
                case 'waveform':
                    this.drawWaveform(waveformData);
                    break;
                case 'sacred':
                    this.drawSacredGeometry(audioData);
                    break;
            }
        }

        drawSpectrum(data) {
            const barCount = 64;
            const barWidth = this.width / barCount;
            const coherence = this.bioData.coherence || 0.5;

            for (let i = 0; i < barCount; i++) {
                const value = data[Math.floor(i * data.length / barCount)] / 255;
                const barHeight = value * this.height * 0.6;

                const hue = 320 - i * 2 + coherence * 60;
                const saturation = 80 + coherence * 20;

                const gradient = this.ctx.createLinearGradient(0, this.height, 0, this.height - barHeight);
                gradient.addColorStop(0, `hsla(${hue}, ${saturation}%, 50%, 0.8)`);
                gradient.addColorStop(1, `hsla(${hue + 40}, ${saturation}%, 60%, 0.4)`);

                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(
                    i * barWidth + 2,
                    this.height - barHeight,
                    barWidth - 4,
                    barHeight
                );

                // Glow
                this.ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;
                this.ctx.shadowBlur = 20 * value;
            }
            this.ctx.shadowBlur = 0;
        }

        drawWaveform(data) {
            const coherence = this.bioData.coherence || 0.5;

            this.ctx.beginPath();
            this.ctx.strokeStyle = `rgba(0, 255, 255, ${0.5 + coherence * 0.5})`;
            this.ctx.lineWidth = 2 + coherence * 2;
            this.ctx.shadowColor = '#00FFFF';
            this.ctx.shadowBlur = 20;

            const sliceWidth = this.width / data.length;
            let x = 0;

            for (let i = 0; i < data.length; i++) {
                const v = data[i] / 128.0;
                const y = (v * this.height) / 2;

                if (i === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
                x += sliceWidth;
            }

            this.ctx.stroke();
            this.ctx.shadowBlur = 0;
        }

        drawSacredGeometry(data) {
            const cx = this.width / 2;
            const cy = this.height / 2;
            const coherence = this.bioData.coherence || 0.5;
            const avgVolume = data.reduce((a, b) => a + b, 0) / data.length / 255;
            const baseRadius = Math.min(this.width, this.height) * 0.3;

            // Flower of Life
            const petalCount = 6;
            const radius = baseRadius * (0.8 + avgVolume * 0.4);

            this.ctx.strokeStyle = `rgba(153, 51, 255, ${0.3 + coherence * 0.4})`;
            this.ctx.lineWidth = 1 + coherence;
            this.ctx.shadowColor = '#9933FF';
            this.ctx.shadowBlur = 15;

            // Center circle
            this.ctx.beginPath();
            this.ctx.arc(cx, cy, radius * 0.3, 0, Math.PI * 2);
            this.ctx.stroke();

            // Petals
            for (let i = 0; i < petalCount; i++) {
                const angle = (i / petalCount) * Math.PI * 2;
                const px = cx + Math.cos(angle) * radius * 0.3;
                const py = cy + Math.sin(angle) * radius * 0.3;

                this.ctx.beginPath();
                this.ctx.arc(px, py, radius * 0.3, 0, Math.PI * 2);
                this.ctx.stroke();
            }

            // Outer ring
            this.ctx.strokeStyle = `rgba(255, 20, 148, ${0.2 + avgVolume * 0.5})`;
            this.ctx.beginPath();
            this.ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            this.ctx.stroke();

            // Audio reactive rays
            const rayCount = 12;
            this.ctx.strokeStyle = `rgba(0, 255, 255, ${0.3 + coherence * 0.4})`;
            for (let i = 0; i < rayCount; i++) {
                const dataIndex = Math.floor(i * data.length / rayCount);
                const value = data[dataIndex] / 255;
                const angle = (i / rayCount) * Math.PI * 2;
                const innerR = radius * 0.5;
                const outerR = radius * (1 + value * 0.5);

                this.ctx.beginPath();
                this.ctx.moveTo(cx + Math.cos(angle) * innerR, cy + Math.sin(angle) * innerR);
                this.ctx.lineTo(cx + Math.cos(angle) * outerR, cy + Math.sin(angle) * outerR);
                this.ctx.stroke();
            }

            this.ctx.shadowBlur = 0;
        }

        setMode(mode) {
            this.mode = mode;
        }
    }

    // ==================== MAIN APP ====================
    class EchoelmusicApp {
        constructor() {
            this.audio = new AudioEngine();
            this.bio = new BioSimulator();
            this.visualizer = new Visualizer(document.getElementById('visualizer-canvas'));
            this.isStarted = false;
            this.setupEventListeners();
        }

        async start() {
            await this.audio.init();
            this.bio.start();
            this.bio.onUpdate(data => this.onBioUpdate(data));
            this.animate();
            this.isStarted = true;
            document.getElementById('startOverlay').classList.add('hidden');
            this.showStatus('Bio-reactive mode active');
        }

        setupEventListeners() {
            // Start button
            document.getElementById('startBtn').addEventListener('click', () => this.start());

            // Touch pad
            const touchPad = document.getElementById('touchPad');
            const indicator = document.getElementById('touchIndicator');

            const handleTouch = (e) => {
                e.preventDefault();
                const rect = touchPad.getBoundingClientRect();
                const touch = e.touches ? e.touches[0] : e;
                const x = (touch.clientX - rect.left) / rect.width;
                const y = 1 - (touch.clientY - rect.top) / rect.height;

                indicator.style.left = (x * 100) + '%';
                indicator.style.top = ((1 - y) * 100) + '%';
                indicator.classList.add('active');

                const frequency = 110 * Math.pow(2, x * 3); // A2 to A5

                if (!this.audio.isPlaying) {
                    this.audio.startNote(frequency);
                } else {
                    this.audio.updateNote(frequency, y);
                }
            };

            const handleEnd = () => {
                indicator.classList.remove('active');
                this.audio.stopNote();
            };

            touchPad.addEventListener('mousedown', handleTouch);
            touchPad.addEventListener('mousemove', (e) => { if (e.buttons) handleTouch(e); });
            touchPad.addEventListener('mouseup', handleEnd);
            touchPad.addEventListener('mouseleave', handleEnd);
            touchPad.addEventListener('touchstart', handleTouch);
            touchPad.addEventListener('touchmove', handleTouch);
            touchPad.addEventListener('touchend', handleEnd);

            // Waveform buttons
            document.querySelectorAll('.wave-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.wave-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.audio.setWaveform(btn.dataset.wave);
                    this.showStatus(`Waveform: ${btn.dataset.wave}`);
                });
            });

            // Knobs
            document.querySelectorAll('.knob').forEach(knob => {
                let isDragging = false;
                let startY = 0;
                let startValue = 0;

                const handleDrag = (e) => {
                    if (!isDragging) return;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    const delta = (startY - clientY) / 100;
                    const value = Math.max(0, Math.min(1, startValue + delta));
                    knob.style.setProperty('--value', value);
                    this.audio.setParam(knob.dataset.param, value);
                };

                knob.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    startY = e.clientY;
                    startValue = parseFloat(knob.style.getPropertyValue('--value')) || 0.5;
                });

                knob.addEventListener('touchstart', (e) => {
                    isDragging = true;
                    startY = e.touches[0].clientY;
                    startValue = parseFloat(knob.style.getPropertyValue('--value')) || 0.5;
                });

                document.addEventListener('mousemove', handleDrag);
                document.addEventListener('touchmove', handleDrag);
                document.addEventListener('mouseup', () => { isDragging = false; });
                document.addEventListener('touchend', () => { isDragging = false; });
            });

            // Visualizer modes
            document.querySelectorAll('.viz-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.viz-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.visualizer.setMode(btn.dataset.viz);
                    this.showStatus(`Visualizer: ${btn.dataset.viz}`);
                });
            });
        }

        onBioUpdate(data) {
            // Update UI
            document.getElementById('heartValue').textContent = data.heartRate;
            document.getElementById('hrvValue').textContent = data.hrv;
            document.getElementById('coherenceValue').textContent = data.coherence.toFixed(2);

            // Update visualizer
            this.visualizer.setBioData(data);

            // Bio-reactive audio modulation
            if (this.audio.filter) {
                // Coherence affects filter resonance
                this.audio.filter.Q.setTargetAtTime(1 + data.coherence * 10, this.audio.ctx.currentTime, 0.1);
            }
        }

        animate() {
            if (this.isStarted) {
                const audioData = this.audio.getAnalyserData();
                const waveformData = this.audio.getWaveformData();
                this.visualizer.draw(audioData, waveformData);
            }
            requestAnimationFrame(() => this.animate());
        }

        showStatus(message) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.classList.add('visible');
            setTimeout(() => status.classList.remove('visible'), 2000);
        }
    }

    // Initialize
    const app = new EchoelmusicApp();
    </script>
</body>
</html>
