# =============================================================================
# ECHOELMUSIC - FASTLANE CONFIGURATION (Upload Only)
# =============================================================================
# xcodebuild handles archive + export directly in CI workflow
# Fastlane only handles TestFlight upload with retry logic
# =============================================================================

default_platform(:ios)

TEAM_ID = ENV["APPLE_TEAM_ID"]
BUILD_NUMBER = ENV["BUILD_NUMBER"] || "1"

# =============================================================================
# SHARED HELPERS
# =============================================================================

def setup_api_key
  missing = []
  missing << "ASC_KEY_ID" unless ENV["ASC_KEY_ID"]&.length.to_i > 0
  missing << "ASC_ISSUER_ID" unless ENV["ASC_ISSUER_ID"]&.length.to_i > 0
  missing << "ASC_KEY_CONTENT" unless ENV["ASC_KEY_CONTENT"]&.length.to_i > 0
  missing << "APPLE_TEAM_ID" unless ENV["APPLE_TEAM_ID"]&.length.to_i > 0

  unless missing.empty?
    UI.error("Missing required environment variables: #{missing.join(', ')}")
    UI.user_error!("Cannot proceed without App Store Connect credentials")
  end

  key_content = ENV["ASC_KEY_CONTENT"]
  unless key_content.include?("BEGIN") && key_content.include?("PRIVATE KEY")
    UI.important("Warning: ASC_KEY_CONTENT may not be in correct PEM format")
  end

  app_store_connect_api_key(
    key_id: ENV["ASC_KEY_ID"],
    issuer_id: ENV["ASC_ISSUER_ID"],
    key_content: key_content,
    is_key_content_base64: false,
    in_house: false
  )
end

def upload_to_testflight_with_retry(api_key, changelog, ipa_path: nil, max_retries: 3)
  UI.message("Uploading to TestFlight...")
  UI.message("IPA path: #{ipa_path || '(auto-detect)'}")

  retries = 0
  begin
    params = {
      api_key: api_key,
      skip_waiting_for_build_processing: true,
      distribute_external: false,
      notify_external_testers: false,
      changelog: changelog,
      reject_build_waiting_for_review: false
    }
    params[:ipa] = ipa_path if ipa_path
    upload_to_testflight(params)
    UI.success("Successfully uploaded to TestFlight!")
  rescue => e
    retries += 1
    if retries <= max_retries
      delay = 30 * retries
      UI.important("Upload failed (attempt #{retries}/#{max_retries}): #{e.message}")
      UI.message("Retrying in #{delay} seconds...")
      sleep(delay)
      retry
    else
      UI.error("Upload failed after #{max_retries} attempts")
      raise e
    end
  end
end

# =============================================================================
# SIGNING HELPER â€” Revokes stale certs and creates fresh ones
# =============================================================================

def setup_signing_certs(cert_platform: "ios")
  api_key = setup_api_key
  keychain_path = "#{ENV['HOME']}/Library/Keychains/build.keychain-db"
  keychain_password = ""

  # Step 1: Revoke ALL development certificates to clear the limit
  # Fastlane's cert --force only revokes one, but the limit may already be maxed
  UI.message("Revoking ALL development certificates via API...")
  begin
    token = Spaceship::ConnectAPI::Token.create(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key: ENV["ASC_KEY_CONTENT"]
    )
    Spaceship::ConnectAPI.token = token

    certs = Spaceship::ConnectAPI::Certificate.all
    dev_certs = certs.select { |c|
      t = c.certificate_type
      t == "DEVELOPMENT" || t == "IOS_DEVELOPMENT" || t == "MAC_APP_DEVELOPMENT"
    }

    UI.message("Found #{dev_certs.count} development certificate(s), revoking all...")
    dev_certs.each do |c|
      UI.message("  Revoking #{c.id} (#{c.certificate_type})")
      c.delete!
    end
    UI.success("All #{dev_certs.count} development certificates revoked")
  rescue => e
    UI.important("Warning during cert revocation: #{e.message}")
    UI.important("Continuing anyway - cert action will try to create/reuse...")
  end

  # Step 2: Create a fresh Development certificate for the requested platform
  UI.message("Creating fresh Development certificate for platform: #{cert_platform}...")
  cert(
    development: true,
    api_key: api_key,
    generate_apple_certs: true,
    keychain_path: keychain_path,
    keychain_password: keychain_password,
    platform: cert_platform
  )
  UI.success("Fresh #{cert_platform} Development certificate installed in keychain")
end

# =============================================================================
# iOS PLATFORM
# =============================================================================

platform :ios do

  desc "Setup signing certificates (revoke stale, create fresh)"
  lane :setup_signing do
    setup_signing_certs(cert_platform: "ios")
  end

  desc "Upload iOS IPA to TestFlight (archive built by xcodebuild in CI)"
  lane :upload do
    UI.header "iOS TestFlight Upload"
    api_key = setup_api_key

    # Use absolute path from ENV, or search common locations
    ipa_path = ENV["IPA_PATH"]
    ipa_path = File.expand_path(ipa_path) if ipa_path

    unless ipa_path && File.exist?(ipa_path)
      UI.message("IPA_PATH='#{ipa_path}' not found, searching...")
      UI.message("CWD: #{Dir.pwd}")

      # Search in common locations
      candidates = Dir["#{Dir.pwd}/build/*.ipa"] +
                   Dir["#{Dir.pwd}/../build/*.ipa"] +
                   Dir["./build/*.ipa"]
      UI.message("Found IPA candidates: #{candidates}")
      ipa_path = candidates.first
    end

    unless ipa_path && File.exist?(ipa_path)
      UI.message("Contents of build dir:")
      Dir["#{Dir.pwd}/build/**/*"].each { |f| UI.message("  #{f}") } rescue nil
      Dir["./build/**/*"].each { |f| UI.message("  #{f}") } rescue nil
      UI.user_error!("No IPA found! CWD=#{Dir.pwd}")
    end

    UI.message("Using IPA: #{ipa_path}")

    upload_to_testflight_with_retry(api_key, "iOS Build #{BUILD_NUMBER}", ipa_path: ipa_path)
  end

  desc "Upload watchOS to TestFlight"
  lane :upload_watchos do
    UI.header "watchOS TestFlight Upload"
    api_key = setup_api_key
    upload_to_testflight_with_retry(api_key, "watchOS Build #{BUILD_NUMBER}")
  end

  desc "Upload tvOS to TestFlight"
  lane :upload_tvos do
    UI.header "tvOS TestFlight Upload"
    api_key = setup_api_key
    upload_to_testflight_with_retry(api_key, "tvOS Build #{BUILD_NUMBER}")
  end

  desc "Upload visionOS to TestFlight"
  lane :upload_visionos do
    UI.header "visionOS TestFlight Upload"
    api_key = setup_api_key
    upload_to_testflight_with_retry(api_key, "visionOS Build #{BUILD_NUMBER}")
  end

  desc "Just build without signing (for CI testing)"
  lane :build_only do
    UI.header "Building iOS for simulator (no signing)"
    build_app(
      project: "Echoelmusic.xcodeproj",
      scheme: "Echoelmusic",
      configuration: "Release",
      clean: false,
      skip_codesigning: true,
      skip_archive: true,
      destination: "generic/platform=iOS Simulator",
      derived_data_path: "./build/DerivedData"
    )
  end

  desc "Run iOS tests"
  lane :test do
    run_tests(
      project: "Echoelmusic.xcodeproj",
      scheme: "Echoelmusic",
      device: "iPhone 15 Pro",
      clean: false,
      derived_data_path: "./build/DerivedData"
    )
  end
end

# =============================================================================
# macOS PLATFORM
# =============================================================================

platform :mac do

  desc "Setup macOS signing certificates (revoke stale, create fresh)"
  lane :setup_signing do
    setup_signing_certs(cert_platform: "macos")
  end

  desc "Upload macOS app to TestFlight"
  lane :upload do
    UI.header "macOS TestFlight Upload"
    api_key = setup_api_key
    upload_to_testflight_with_retry(api_key, "macOS Build #{BUILD_NUMBER}")
  end

  desc "Just build macOS without signing"
  lane :build_only do
    build_app(
      project: "Echoelmusic.xcodeproj",
      scheme: "Echoelmusic-macOS",
      configuration: "Release",
      clean: false,
      skip_codesigning: true,
      skip_archive: true,
      derived_data_path: "./build/DerivedData"
    )
  end

  desc "Run macOS tests"
  lane :test do
    run_tests(
      project: "Echoelmusic.xcodeproj",
      scheme: "Echoelmusic-macOS",
      clean: false,
      derived_data_path: "./build/DerivedData"
    )
  end
end
