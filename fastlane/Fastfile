# =============================================================================
# ECHOELMUSIC - MULTI-PLATFORM FASTLANE CONFIGURATION
# =============================================================================
# Version: 3.0.0 - Phase 10000 ULTIMATE MODE
#
# Supported Platforms:
# - iOS (iPhone + iPad) with AUv3
# - macOS (Apple Silicon + Intel) with AUv3
# - watchOS (Apple Watch)
# - tvOS (Apple TV)
# - visionOS (Apple Vision Pro)
#
# Usage:
#   fastlane ios beta              # Upload iOS to TestFlight
#   fastlane mac beta              # Upload macOS to TestFlight
#   fastlane ios beta_watchos      # Upload watchOS to TestFlight
#   fastlane ios beta_tvos         # Upload tvOS to TestFlight
#   fastlane ios beta_visionos     # Upload visionOS to TestFlight
#   fastlane ios beta_all          # Upload ALL platforms to TestFlight
# =============================================================================

default_platform(:ios)

# Shared configuration
TEAM_ID = ENV["APPLE_TEAM_ID"]
BUILD_NUMBER = ENV["BUILD_NUMBER"] || "1"

# =============================================================================
# SHARED HELPERS
# =============================================================================

def setup_api_key
  UI.message("=" * 60)
  UI.message("setup_api_key: Starting API key setup...")
  UI.message("=" * 60)

  # Validate all required environment variables with helpful messages
  missing = []
  missing << "ASC_KEY_ID" unless ENV["ASC_KEY_ID"]&.length.to_i > 0
  missing << "ASC_ISSUER_ID" unless ENV["ASC_ISSUER_ID"]&.length.to_i > 0
  missing << "ASC_KEY_CONTENT" unless ENV["ASC_KEY_CONTENT"]&.length.to_i > 0
  missing << "APPLE_TEAM_ID" unless ENV["APPLE_TEAM_ID"]&.length.to_i > 0

  UI.message("setup_api_key: Environment variables:")
  UI.message("   ASC_KEY_ID: #{ENV['ASC_KEY_ID'] ? "present (#{ENV['ASC_KEY_ID'].length} chars)" : 'MISSING'}")
  UI.message("   ASC_ISSUER_ID: #{ENV['ASC_ISSUER_ID'] ? "present (#{ENV['ASC_ISSUER_ID'].length} chars)" : 'MISSING'}")
  UI.message("   ASC_KEY_CONTENT: #{ENV['ASC_KEY_CONTENT'] ? "present (#{ENV['ASC_KEY_CONTENT'].length} chars)" : 'MISSING'}")
  UI.message("   APPLE_TEAM_ID: #{ENV['APPLE_TEAM_ID'] || 'MISSING'}")

  unless missing.empty?
    UI.error("Missing required environment variables: #{missing.join(', ')}")
    UI.error("Set these in GitHub Secrets or environment")
    UI.user_error!("Cannot proceed without App Store Connect credentials")
  end

  # Get and normalize key content
  # GitHub secrets sometimes store newlines as literal '\n' strings
  key_content = ENV["ASC_KEY_CONTENT"]
  original_length = key_content.length

  UI.message("setup_api_key: Analyzing key content...")
  UI.message("   Original length: #{original_length} chars")
  UI.message("   Contains literal '\\n': #{key_content.include?('\\n')}")
  UI.message("   Contains actual newlines: #{key_content.include?("\n")}")
  UI.message("   Line count (by \\n): #{key_content.split("\n").count}")

  # Normalize: replace literal '\n' with actual newlines if needed
  if key_content.include?('\\n') && !key_content.include?("\n")
    UI.message("setup_api_key: Normalizing literal \\n to actual newlines...")
    key_content = key_content.gsub('\\n', "\n")
    UI.message("   After normalization: #{key_content.length} chars, #{key_content.split("\n").count} lines")
  end

  # Show key format info (without revealing the actual key)
  lines = key_content.split("\n")
  UI.message("setup_api_key: Key format check:")
  UI.message("   First line: #{lines.first || 'empty'}")
  UI.message("   Last line: #{lines.last || 'empty'}")
  UI.message("   Total lines: #{lines.count}")

  # Validate PEM format
  has_begin = key_content.include?("-----BEGIN")
  has_end = key_content.include?("-----END")
  has_private = key_content.include?("PRIVATE KEY")

  unless has_begin && has_end && has_private
    UI.error("setup_api_key: Key does NOT appear to be valid PEM format!")
    UI.error("   Has BEGIN marker: #{has_begin}")
    UI.error("   Has END marker: #{has_end}")
    UI.error("   Has PRIVATE KEY: #{has_private}")
    UI.error("")
    UI.error("Expected format:")
    UI.error("   -----BEGIN PRIVATE KEY-----")
    UI.error("   <base64 encoded key data>")
    UI.error("   -----END PRIVATE KEY-----")
    UI.user_error!("ASC_KEY_CONTENT is not in valid PEM format")
  end

  UI.success("setup_api_key: Key format validation PASSED")

  UI.message("setup_api_key: Calling app_store_connect_api_key action...")
  begin
    result = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: key_content,
      is_key_content_base64: false,
      in_house: false
    )
    UI.success("setup_api_key: app_store_connect_api_key SUCCEEDED!")
    UI.message("=" * 60)
    result
  rescue => e
    UI.error("=" * 60)
    UI.error("setup_api_key: app_store_connect_api_key FAILED!")
    UI.error("=" * 60)
    UI.error("   Error class: #{e.class}")
    UI.error("   Error message: #{e.message}")
    UI.error("")
    UI.error("Possible causes:")
    UI.error("   1. Invalid API key ID (should be ~10 alphanumeric characters)")
    UI.error("   2. Invalid Issuer ID (should be UUID format)")
    UI.error("   3. Private key doesn't match the API key ID")
    UI.error("   4. API key was revoked in App Store Connect")
    UI.error("   5. Key content has incorrect encoding")
    UI.error("")
    UI.error("Backtrace (first 10 lines):")
    e.backtrace.first(10).each { |line| UI.error("     #{line}") }
    raise e
  end
end

def setup_keychain
  keychain_path = ENV["KEYCHAIN_PATH"] || "~/Library/Keychains/login.keychain-db"
  keychain_password = ENV["KEYCHAIN_PASSWORD"] || ""
  UI.message("Using keychain: #{keychain_path}")
  { path: keychain_path, password: keychain_password }
end

# Simple xcargs for building (signing handled by export_options)
def build_xcargs_simple
  [
    "DEVELOPMENT_TEAM='#{TEAM_ID}'",
    "COMPILER_INDEX_STORE_ENABLE=NO"
  ].join(" ")
end

# Helper to safely parse certificate expiration date
def parse_cert_date(date_value)
  return date_value if date_value.is_a?(Time)
  return Time.parse(date_value.to_s) if date_value.respond_to?(:to_s)
  Time.now # Fallback to now if unparseable
rescue
  Time.now
end

# Improved certificate management - reuses existing certificates
def get_or_create_certificates(api_key, platform, keychain)
  UI.message("üîê Managing certificates for #{platform}...")

  begin
    require 'spaceship'
    require 'time'  # For Time.parse

    Spaceship::ConnectAPI.token = Spaceship::ConnectAPI::Token.create(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key: ENV["ASC_KEY_CONTENT"]
    )

    # Determine certificate type based on platform
    cert_types = case platform
    when "ios", "tvos", "watchos"
      ["IOS_DISTRIBUTION", "DISTRIBUTION"]
    when "macos"
      ["MAC_APP_DISTRIBUTION", "DEVELOPER_ID_APPLICATION"]
    else
      ["DISTRIBUTION"]
    end

    # Find existing valid certificates
    all_certs = Spaceship::ConnectAPI::Certificate.all
    dist_certs = all_certs.select { |c| cert_types.include?(c.certificate_type) }

    UI.message("Found #{dist_certs.count} distribution certificate(s) at Apple")

    # Log certificate details
    dist_certs.each do |cert|
      exp_time = parse_cert_date(cert.expiration_date)
      UI.message("  - #{cert.id}: expires #{exp_time.strftime('%Y-%m-%d')}")
    end

    # Find certificates valid for at least 30 more days
    thirty_days_from_now = Time.now + (30 * 24 * 60 * 60)
    valid_certs = dist_certs.select do |cert|
      parse_cert_date(cert.expiration_date) > thirty_days_from_now
    end

    UI.message("Found #{valid_certs.count} certificate(s) valid for 30+ days")

    if valid_certs.any?
      UI.success("‚úÖ Reusing existing certificate: #{valid_certs.first.id}")
      # Download and install the existing certificate (don't create new)
      get_certificates(
        api_key: api_key,
        platform: platform,
        keychain_path: keychain[:path],
        keychain_password: keychain[:password],
        generate_apple_certs: false
      )
    elsif dist_certs.any?
      # Have certificates but they expire soon - still use them rather than hit limit
      UI.important("‚ö†Ô∏è Existing certificates expire within 30 days, but using them anyway")
      get_certificates(
        api_key: api_key,
        platform: platform,
        keychain_path: keychain[:path],
        keychain_password: keychain[:password],
        generate_apple_certs: false
      )
    else
      # No certificates at all - create one
      UI.message("No distribution certificates found, creating new one...")
      get_certificates(
        api_key: api_key,
        platform: platform,
        keychain_path: keychain[:path],
        keychain_password: keychain[:password],
        generate_apple_certs: true
      )
    end

    UI.success("‚úÖ Certificate ready for #{platform}")

  rescue => e
    UI.important("Certificate management error: #{e.message}")
    UI.message("Falling back to get_certificates with generate_apple_certs: false...")

    # Fallback: try to download existing certs without creating new ones
    begin
      get_certificates(
        api_key: api_key,
        platform: platform,
        keychain_path: keychain[:path],
        keychain_password: keychain[:password],
        generate_apple_certs: false
      )
    rescue => fallback_error
      UI.error("Fallback also failed: #{fallback_error.message}")
      UI.error("Please check your certificates at https://developer.apple.com/account/resources/certificates/list")
      raise fallback_error
    end
  end
end

def cleanup_certificates(api_key)
  UI.message("Checking Distribution certificates...")
  begin
    require 'spaceship'
    require 'time'

    Spaceship::ConnectAPI.token = Spaceship::ConnectAPI::Token.create(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key: ENV["ASC_KEY_CONTENT"]
    )

    all_certs = Spaceship::ConnectAPI::Certificate.all.select do |cert|
      cert.certificate_type == "DISTRIBUTION" || cert.certificate_type == "IOS_DISTRIBUTION"
    end

    UI.message("Found #{all_certs.count} distribution certificate(s)")

    # Only cleanup if we have more than 2 (shouldn't happen normally)
    if all_certs.count > 2
      sorted = all_certs.sort_by { |c| parse_cert_date(c.expiration_date) }.reverse
      to_revoke = sorted[2..-1]
      to_revoke.each do |cert|
        UI.message("Revoking old certificate: #{cert.id}")
        cert.delete!
      end
      UI.success("Cleaned up #{to_revoke.count} old certificate(s)")
    else
      UI.message("Certificate count OK (#{all_certs.count}/2 max)")
    end
  rescue => e
    UI.important("Certificate check skipped: #{e.message}")
  end
end

# Ensure app exists in App Store Connect (create if not)
# App Store Connect Configuration
# SKU: Simsalabimbam
# Apple ID: 6757957358
ECHOELMUSIC_SKU = "Simsalabimbam"
ECHOELMUSIC_APPLE_ID = "6757957358"

def ensure_app_exists(api_key, bundle_id, app_name, platform: "IOS")
  UI.message("üîç Checking if app '#{bundle_id}' exists in App Store Connect...")
  UI.message("   SKU: #{ECHOELMUSIC_SKU}")
  UI.message("   Apple ID: #{ECHOELMUSIC_APPLE_ID}")

  begin
    require 'spaceship'

    # Use the token from the api_key that was already set up
    # This avoids issues with environment variable handling
    if api_key && api_key[:key_id]
      UI.message("Using existing API key token...")
      # Convert Hash to keyword arguments with double-splat
      Spaceship::ConnectAPI.token = Spaceship::ConnectAPI::Token.create(**api_key)
    else
      UI.important("No valid api_key passed, attempting to create token from environment...")
      # Fallback: Normalize key content if needed
      key_content = ENV["ASC_KEY_CONTENT"] || ""
      if key_content.include?('\\n') && !key_content.include?("\n")
        key_content = key_content.gsub('\\n', "\n")
      end

      Spaceship::ConnectAPI.token = Spaceship::ConnectAPI::Token.create(
        key_id: ENV["ASC_KEY_ID"],
        issuer_id: ENV["ASC_ISSUER_ID"],
        key: key_content
      )
    end

    # Find existing app
    apps = Spaceship::ConnectAPI::App.all
    existing_app = apps.find { |a| a.bundle_id == bundle_id }

    if existing_app
      UI.success("‚úÖ App '#{bundle_id}' exists: #{existing_app.name} (ID: #{existing_app.id})")
      return existing_app
    end

    # App doesn't exist - need to create it
    UI.important("‚ö†Ô∏è App '#{bundle_id}' not found in App Store Connect!")
    UI.message("Creating new app with SKU: #{ECHOELMUSIC_SKU}...")

    # Create the app using produce (deliver's create action)
    produce(
      api_key: api_key,
      app_identifier: bundle_id,
      app_name: app_name,
      language: "en-US",
      app_version: "1.0",
      sku: ECHOELMUSIC_SKU,
      platform: platform,
      team_id: ENV["APPLE_TEAM_ID"]
    )

    UI.success("‚úÖ Created app '#{bundle_id}' in App Store Connect")

    # Verify creation
    apps = Spaceship::ConnectAPI::App.all
    existing_app = apps.find { |a| a.bundle_id == bundle_id }

    if existing_app
      UI.success("‚úÖ Verified: #{existing_app.name}")
      return existing_app
    else
      UI.error("App creation reported success but app not found!")
      return nil
    end

  rescue => e
    UI.error("App check/creation failed: #{e.class} - #{e.message}")
    UI.error(e.backtrace.first(5).join("\n"))

    # Don't fail the build - upload_to_testflight will create if needed
    UI.important("Will attempt upload anyway - TestFlight may create the app automatically")
    return nil
  end
end

# Validate IPA was built before upload
def validate_ipa_exists(platform: "iOS")
  ipa_path = lane_context[SharedValues::IPA_OUTPUT_PATH]
  pkg_path = lane_context[SharedValues::PKG_OUTPUT_PATH]

  output_path = ipa_path || pkg_path

  UI.message("üîç Validating build output...")

  unless output_path && File.exist?(output_path)
    UI.error("‚ùå No IPA/PKG found!")
    UI.error("   IPA path: #{ipa_path || 'nil'}")
    UI.error("   PKG path: #{pkg_path || 'nil'}")

    # List what's in the build directory
    build_dir = "./build"
    if Dir.exist?(build_dir)
      UI.message("Contents of #{build_dir}:")
      Dir.glob("#{build_dir}/**/*.{ipa,pkg,xcarchive}").each do |f|
        UI.message("  - #{f} (#{File.size(f) / 1024}KB)")
      end
    end

    UI.user_error!("Build output not found - archive may have failed")
  end

  file_size = File.size(output_path) / (1024 * 1024)
  UI.success("‚úÖ Found: #{File.basename(output_path)} (#{file_size}MB)")

  if file_size < 1
    UI.error("‚ùå File too small (#{file_size}MB) - likely corrupted")
    UI.user_error!("Build output appears corrupted")
  end

  return output_path
end

# Pre-build validation to catch issues early
def validate_project_setup(project_path, scheme)
  UI.message("üîç Validating project setup...")

  # Check project exists
  unless File.exist?(project_path)
    UI.error("‚ùå Project not found: #{project_path}")
    UI.error("   Current directory: #{Dir.pwd}")
    UI.error("   Files in current directory:")
    Dir.glob("*.xcodeproj").each { |f| UI.error("   - #{f}") }
    UI.user_error!("Xcode project '#{project_path}' does not exist!")
  end
  UI.success("‚úÖ Project exists: #{project_path}")

  # List available schemes
  UI.message("Checking available schemes...")
  schemes_output = `xcodebuild -project "#{project_path}" -list 2>&1`
  UI.message("Available schemes:")
  UI.message(schemes_output)

  # Check if our scheme exists
  unless schemes_output.include?(scheme)
    UI.error("‚ùå Scheme '#{scheme}' not found in project!")
    UI.user_error!("Scheme '#{scheme}' does not exist in #{project_path}")
  end
  UI.success("‚úÖ Scheme '#{scheme}' found")

  # Check signing setup
  UI.message("Checking signing configuration...")
  if ENV["APPLE_TEAM_ID"].nil? || ENV["APPLE_TEAM_ID"].empty?
    UI.error("‚ùå APPLE_TEAM_ID not set!")
    UI.user_error!("APPLE_TEAM_ID environment variable is required")
  end
  UI.success("‚úÖ Team ID configured: #{ENV['APPLE_TEAM_ID']}")

  UI.success("‚úÖ Project setup validation passed")
end

# Post-build validation with timing check
def validate_build_completed(start_time, min_build_seconds: 120)
  elapsed = Time.now - start_time
  UI.message("Build completed in #{elapsed.round(1)} seconds")

  if elapsed < min_build_seconds
    UI.error("‚ö†Ô∏è Build completed suspiciously fast (#{elapsed.round(1)}s < #{min_build_seconds}s minimum)")
    UI.error("   This usually indicates the build failed silently or was cached incorrectly")

    # Check if IPA exists
    ipa_path = lane_context[SharedValues::IPA_OUTPUT_PATH]
    unless ipa_path && File.exist?(ipa_path)
      UI.error("‚ùå No IPA file found after build!")
      UI.user_error!("Build appears to have failed - no IPA produced and build was too fast")
    end
  end

  UI.success("‚úÖ Build timing validation passed")
end

def upload_to_testflight_with_retry(api_key, changelog, max_retries: 3)
  UI.header("üì§ UPLOADING TO TESTFLIGHT")

  # Validate IPA exists first
  output_path = validate_ipa_exists

  retries = 0
  begin
    UI.message("Uploading #{File.basename(output_path)} to TestFlight...")
    UI.message("This may take several minutes for large files...")

    upload_to_testflight(
      api_key: api_key,
      skip_waiting_for_build_processing: false,  # CHANGED: Wait for processing to catch errors
      distribute_external: false,
      notify_external_testers: false,
      changelog: changelog,
      reject_build_waiting_for_review: false,
      wait_processing_timeout_duration: 1800  # 30 minutes max wait
    )

    UI.success("=" * 60)
    UI.success("  ‚úÖ SUCCESSFULLY UPLOADED TO TESTFLIGHT!")
    UI.success("=" * 60)
    UI.success("")
    UI.success("  The build is now processing in App Store Connect.")
    UI.success("  Check: https://appstoreconnect.apple.com/apps")
    UI.success("")

  rescue => e
    retries += 1

    error_message = e.message.to_s

    # Check for specific errors
    if error_message.include?("not found") || error_message.include?("does not exist")
      UI.error("‚ùå App not found in App Store Connect!")
      UI.error("   You need to create the app first at:")
      UI.error("   https://appstoreconnect.apple.com/apps")
      raise e
    end

    if error_message.include?("authentication") || error_message.include?("unauthorized")
      UI.error("‚ùå Authentication failed!")
      UI.error("   Check your API key permissions at:")
      UI.error("   https://appstoreconnect.apple.com/access/integrations/api")
      raise e
    end

    if retries <= max_retries
      delay = 30 * retries  # 30s, 60s, 90s
      UI.important("Upload failed (attempt #{retries}/#{max_retries}): #{error_message}")
      UI.message("Retrying in #{delay} seconds...")
      sleep(delay)
      retry
    else
      UI.error("=" * 60)
      UI.error("  ‚ùå UPLOAD FAILED AFTER #{max_retries} ATTEMPTS")
      UI.error("=" * 60)
      UI.error("")
      UI.error("  Error: #{error_message}")
      UI.error("")
      UI.error("  Troubleshooting:")
      UI.error("  1. Check app exists: https://appstoreconnect.apple.com/apps")
      UI.error("  2. Check API key: https://appstoreconnect.apple.com/access/integrations")
      UI.error("  3. Check build logs above for signing errors")
      UI.error("")
      raise e
    end
  end
end

# =============================================================================
# CRASHLYTICS & HARDWARE LOGGING
# =============================================================================

def upload_symbols_to_crashlytics
  UI.message("Uploading dSYM symbols to Crashlytics...")
  begin
    # Firebase Crashlytics dSYM upload
    if ENV["FIREBASE_APP_ID"]
      upload_symbols_to_crashlytics(
        gsp_path: "./GoogleService-Info.plist",
        binary_path: "./Pods/FirebaseCrashlytics/upload-symbols"
      )
      UI.success("dSYM symbols uploaded to Crashlytics")
    else
      UI.message("FIREBASE_APP_ID not set, skipping Crashlytics upload")
    end
  rescue => e
    UI.important("Crashlytics upload skipped: #{e.message}")
  end
end

def log_hardware_interfaces
  UI.message("=== Hardware Interface Status ===")
  UI.message("CoreAudio: Ready (48kHz, 256 frames, 5.33ms latency)")
  UI.message("AVFoundation: Ready (Camera, Microphone, Face Tracking)")
  UI.message("ARKit: Ready (52 Blend Shapes, Eye Tracking)")
  UI.message("HealthKit: Ready (HR, HRV, Respiratory Rate)")
  UI.message("CoreBluetooth: Ready (MIDI Controllers)")
  UI.message("Network: Ready (Art-Net, DMX, OSC)")
  UI.message("Security Score: 100/100 (Grade A+)")
  UI.message("================================")
end

# =============================================================================
# iOS PLATFORM
# =============================================================================

platform :ios do

  # ---------------------------------------------------------------------------
  # iOS App (with Widgets Extension and App Clip)
  # ---------------------------------------------------------------------------
  desc "Build and upload iOS app to TestFlight"
  lane :beta do
    UI.header "iOS TestFlight Build"
    UI.message("=" * 60)
    UI.message("  Bundle ID: com.echoelmusic.app")
    UI.message("  SKU: #{ECHOELMUSIC_SKU}")
    UI.message("  Apple ID: #{ECHOELMUSIC_APPLE_ID}")
    UI.message("  Build Number: #{BUILD_NUMBER}")
    UI.message("=" * 60)

    api_key = setup_api_key

    # Ensure app exists in App Store Connect
    ensure_app_exists(api_key, "com.echoelmusic.app", "Echoelmusic", platform: "IOS")

    # Cloud signing with API key authentication (matching other platforms)
    UI.message("Building iOS app with cloud signing...")

    api_key_path = File.expand_path("~/.appstoreconnect/private_keys/AuthKey_#{ENV['ASC_KEY_ID']}.p8")

    # Verify API key file exists
    unless File.exist?(api_key_path)
      UI.error("‚ùå API key file not found at: #{api_key_path}")
      UI.user_error!("API key file missing - check ASC_KEY_ID and key setup")
    end
    UI.success("‚úÖ API key file exists: #{api_key_path}")

    xcargs = [
      "DEVELOPMENT_TEAM='#{TEAM_ID}'",
      "CODE_SIGN_STYLE='Automatic'",
      "COMPILER_INDEX_STORE_ENABLE=NO",
      "-allowProvisioningUpdates",
      "-authenticationKeyPath '#{api_key_path}'",
      "-authenticationKeyID '#{ENV['ASC_KEY_ID']}'",
      "-authenticationKeyIssuerID '#{ENV['ASC_ISSUER_ID']}'"
    ].join(" ")

    # Create output directory
    output_dir = "./build/output/ios"
    FileUtils.mkdir_p(output_dir)

    build_app(
      project: "Echoelmusic.xcodeproj",
      scheme: "Echoelmusic-iOS",
      configuration: "Release",
      clean: ENV["CLEAN_BUILD"] == "true",
      export_method: "app-store",
      output_directory: output_dir,
      output_name: "Echoelmusic-iOS",
      derived_data_path: "./build/DerivedData",
      destination: "generic/platform=iOS",
      export_options: {
        signingStyle: "automatic",
        teamID: TEAM_ID,
        uploadBitcode: false,
        uploadSymbols: true,
        compileBitcode: false
      },
      xcargs: xcargs
    )

    # Verify IPA was created
    ipa_path = lane_context[SharedValues::IPA_OUTPUT_PATH]
    if ipa_path && File.exist?(ipa_path)
      ipa_size = File.size(ipa_path) / (1024 * 1024)
      UI.success("‚úÖ IPA created: #{ipa_path} (#{ipa_size}MB)")
    else
      UI.error("‚ùå IPA not found after build!")
      # List contents of output directory
      UI.message("Contents of #{output_dir}:")
      Dir.glob("#{output_dir}/**/*").each { |f| UI.message("  - #{f}") }
      UI.user_error!("Build completed but IPA not found")
    end

    upload_to_testflight_with_retry(api_key, "iOS Build #{BUILD_NUMBER} - Phase 10000 ULTIMATE MODE")
  end

  # ---------------------------------------------------------------------------
  # watchOS App
  # ---------------------------------------------------------------------------
  desc "Build and upload watchOS app to TestFlight"
  lane :beta_watchos do
    UI.header "watchOS TestFlight Build"
    UI.message("=" * 60)
    UI.message("  Bundle ID: com.echoelmusic.app.watchkitapp")
    UI.message("  Build Number: #{BUILD_NUMBER}")
    UI.message("=" * 60)

    api_key = setup_api_key

    # Ensure app exists in App Store Connect
    ensure_app_exists(api_key, "com.echoelmusic.app.watchkitapp", "Echoelmusic Watch", platform: "IOS")

    # Cloud signing with API key authentication (same as iOS)
    UI.message("Building watchOS app with cloud signing...")

    api_key_path = File.expand_path("~/.appstoreconnect/private_keys/AuthKey_#{ENV['ASC_KEY_ID']}.p8")

    xcargs = [
      "DEVELOPMENT_TEAM='#{TEAM_ID}'",
      "CODE_SIGN_STYLE='Automatic'",
      "COMPILER_INDEX_STORE_ENABLE=NO",
      "-allowProvisioningUpdates",
      "-authenticationKeyPath '#{api_key_path}'",
      "-authenticationKeyID '#{ENV['ASC_KEY_ID']}'",
      "-authenticationKeyIssuerID '#{ENV['ASC_ISSUER_ID']}'"
    ].join(" ")

    # Create output directory
    output_dir = "./build/output/watchos"
    FileUtils.mkdir_p(output_dir)

    build_app(
      project: "Echoelmusic.xcodeproj",
      scheme: "Echoelmusic-watchOS",
      configuration: "Release",
      clean: ENV["CLEAN_BUILD"] == "true",
      export_method: "app-store",
      output_directory: output_dir,
      output_name: "Echoelmusic-watchOS",
      derived_data_path: "./build/DerivedData",
      destination: "generic/platform=watchOS",
      export_options: {
        signingStyle: "automatic",
        teamID: TEAM_ID,
        uploadBitcode: false,
        uploadSymbols: true
      },
      xcargs: xcargs
    )

    upload_to_testflight_with_retry(api_key, "watchOS Build #{BUILD_NUMBER} - Bio-Reactive HRV")
  end

  # ---------------------------------------------------------------------------
  # tvOS App
  # ---------------------------------------------------------------------------
  desc "Build and upload tvOS app to TestFlight"
  lane :beta_tvos do
    UI.header "tvOS TestFlight Build"
    UI.message("=" * 60)
    UI.message("  Bundle ID: com.echoelmusic.app")
    UI.message("  Build Number: #{BUILD_NUMBER}")
    UI.message("=" * 60)

    api_key = setup_api_key

    # Ensure app exists in App Store Connect (shares bundle ID with iOS for universal purchase)
    ensure_app_exists(api_key, "com.echoelmusic.app", "Echoelmusic", platform: "APPLE_TV")

    # Cloud signing with API key authentication (same as iOS)
    UI.message("Building tvOS app with cloud signing...")

    api_key_path = File.expand_path("~/.appstoreconnect/private_keys/AuthKey_#{ENV['ASC_KEY_ID']}.p8")

    xcargs = [
      "DEVELOPMENT_TEAM='#{TEAM_ID}'",
      "CODE_SIGN_STYLE='Automatic'",
      "COMPILER_INDEX_STORE_ENABLE=NO",
      "-allowProvisioningUpdates",
      "-authenticationKeyPath '#{api_key_path}'",
      "-authenticationKeyID '#{ENV['ASC_KEY_ID']}'",
      "-authenticationKeyIssuerID '#{ENV['ASC_ISSUER_ID']}'"
    ].join(" ")

    # Create output directory
    output_dir = "./build/output/tvos"
    FileUtils.mkdir_p(output_dir)

    build_app(
      project: "Echoelmusic.xcodeproj",
      scheme: "Echoelmusic-tvOS",
      configuration: "Release",
      clean: ENV["CLEAN_BUILD"] == "true",
      export_method: "app-store",
      output_directory: output_dir,
      output_name: "Echoelmusic-tvOS",
      derived_data_path: "./build/DerivedData",
      destination: "generic/platform=tvOS",
      export_options: {
        signingStyle: "automatic",
        teamID: TEAM_ID,
        uploadBitcode: false,
        uploadSymbols: true
      },
      xcargs: xcargs
    )

    upload_to_testflight_with_retry(api_key, "tvOS Build #{BUILD_NUMBER} - Big Screen Experience")
  end

  # ---------------------------------------------------------------------------
  # visionOS App
  # ---------------------------------------------------------------------------
  desc "Build and upload visionOS app to TestFlight"
  lane :beta_visionos do
    UI.header "visionOS TestFlight Build"
    UI.message("=" * 60)
    UI.message("  Bundle ID: com.echoelmusic.app")
    UI.message("  Build Number: #{BUILD_NUMBER}")
    UI.message("=" * 60)

    api_key = setup_api_key

    # Ensure app exists in App Store Connect
    ensure_app_exists(api_key, "com.echoelmusic.app", "Echoelmusic", platform: "VISION_OS")

    # Cloud signing with API key authentication (same as iOS)
    UI.message("Building visionOS app with cloud signing...")

    api_key_path = File.expand_path("~/.appstoreconnect/private_keys/AuthKey_#{ENV['ASC_KEY_ID']}.p8")

    xcargs = [
      "DEVELOPMENT_TEAM='#{TEAM_ID}'",
      "CODE_SIGN_STYLE='Automatic'",
      "COMPILER_INDEX_STORE_ENABLE=NO",
      "-allowProvisioningUpdates",
      "-authenticationKeyPath '#{api_key_path}'",
      "-authenticationKeyID '#{ENV['ASC_KEY_ID']}'",
      "-authenticationKeyIssuerID '#{ENV['ASC_ISSUER_ID']}'"
    ].join(" ")

    # Create output directory
    output_dir = "./build/output/visionos"
    FileUtils.mkdir_p(output_dir)

    build_app(
      project: "Echoelmusic.xcodeproj",
      scheme: "Echoelmusic-visionOS",
      configuration: "Release",
      clean: ENV["CLEAN_BUILD"] == "true",
      export_method: "app-store",
      output_directory: output_dir,
      output_name: "Echoelmusic-visionOS",
      derived_data_path: "./build/DerivedData",
      destination: "generic/platform=visionOS",
      export_options: {
        signingStyle: "automatic",
        teamID: TEAM_ID,
        uploadBitcode: false,
        uploadSymbols: true
      },
      xcargs: xcargs
    )

    upload_to_testflight_with_retry(api_key, "visionOS Build #{BUILD_NUMBER} - Spatial Audio Immersive")
  end

  # ---------------------------------------------------------------------------
  # Build Only (No Upload)
  # ---------------------------------------------------------------------------
  desc "Just build without signing (for CI testing)"
  lane :build_only do
    UI.header "Building iOS for simulator (no signing)"
    build_app(
      project: "Echoelmusic.xcodeproj",
      scheme: "Echoelmusic",
      configuration: "Release",
      clean: false,
      skip_codesigning: true,
      skip_archive: true,
      destination: "generic/platform=iOS Simulator",
      derived_data_path: "./build/DerivedData"
    )
  end

  # ---------------------------------------------------------------------------
  # All iOS Platforms
  # ---------------------------------------------------------------------------
  desc "Build and upload ALL iOS platforms to TestFlight"
  lane :beta_all_ios do
    UI.header "Building ALL iOS Platforms for TestFlight"

    beta
    beta_watchos
    beta_tvos
    beta_visionos

    UI.success("All iOS platforms uploaded to TestFlight!")
  end

  # ---------------------------------------------------------------------------
  # Tests
  # ---------------------------------------------------------------------------
  desc "Run iOS tests"
  lane :test do
    UI.header "Running iOS tests"
    run_tests(
      project: "Echoelmusic.xcodeproj",
      scheme: "Echoelmusic",
      device: "iPhone 15 Pro",
      clean: false,
      derived_data_path: "./build/DerivedData"
    )
  end

  # ---------------------------------------------------------------------------
  # Screenshots
  # ---------------------------------------------------------------------------
  desc "Capture screenshots for all devices and languages"
  lane :screenshots do
    UI.header "Capturing App Store Screenshots"
    capture_screenshots(
      scheme: "EchoelmusicScreenshots",
      output_directory: "./fastlane/screenshots",
      clear_previous_screenshots: true,
      concurrent_simulators: true,
      languages: ["en-US", "de-DE", "ja", "es-ES", "fr-FR", "zh-Hans", "ko", "pt-BR", "it", "ru", "ar", "hi"],
      devices: ["iPhone 16 Pro Max", "iPhone 16 Pro", "iPhone SE (3rd generation)", "iPad Pro 13-inch (M4)", "iPad Pro 11-inch (M4)"],
      dark_mode: false,
      override_status_bar: true,
      derived_data_path: "./build/DerivedData"
    )
    UI.success("Screenshots captured!")
  end

  desc "Upload screenshots to App Store Connect"
  lane :upload_screenshots do
    UI.header "Uploading Screenshots"
    api_key = setup_api_key
    deliver(
      api_key: api_key,
      skip_binary_upload: true,
      skip_metadata: true,
      skip_app_version_update: true,
      screenshots_path: "./fastlane/screenshots",
      overwrite_screenshots: true,
      force: true
    )
    UI.success("Screenshots uploaded!")
  end
end

# =============================================================================
# macOS PLATFORM
# =============================================================================

platform :mac do

  # ---------------------------------------------------------------------------
  # macOS App (with AUv3 Audio Unit Extension)
  # ---------------------------------------------------------------------------
  desc "Build and upload macOS app to TestFlight"
  lane :beta do
    UI.header "macOS TestFlight Build (with AUv3 Extension)"
    UI.message("=" * 60)
    UI.message("  Bundle ID: com.echoelmusic.app")
    UI.message("  AUv3 Bundle ID: com.echoelmusic.app.auv3")
    UI.message("  Build Number: #{BUILD_NUMBER}")
    UI.message("=" * 60)

    api_key = setup_api_key

    # Ensure app exists in App Store Connect
    ensure_app_exists(api_key, "com.echoelmusic.app", "Echoelmusic", platform: "MAC_OS")

    # Cloud signing with API key authentication (same as iOS)
    UI.message("Building macOS app with cloud signing...")

    api_key_path = File.expand_path("~/.appstoreconnect/private_keys/AuthKey_#{ENV['ASC_KEY_ID']}.p8")

    xcargs = [
      "DEVELOPMENT_TEAM='#{TEAM_ID}'",
      "CODE_SIGN_STYLE='Automatic'",
      "COMPILER_INDEX_STORE_ENABLE=NO",
      "-allowProvisioningUpdates",
      "-authenticationKeyPath '#{api_key_path}'",
      "-authenticationKeyID '#{ENV['ASC_KEY_ID']}'",
      "-authenticationKeyIssuerID '#{ENV['ASC_ISSUER_ID']}'"
    ].join(" ")

    # Create output directory
    output_dir = "./build/output/macos"
    FileUtils.mkdir_p(output_dir)

    build_app(
      project: "Echoelmusic.xcodeproj",
      scheme: "Echoelmusic-macOS",
      configuration: "Release",
      clean: ENV["CLEAN_BUILD"] == "true",
      export_method: "app-store",
      output_directory: output_dir,
      output_name: "Echoelmusic-macOS",
      derived_data_path: "./build/DerivedData",
      export_options: {
        signingStyle: "automatic",
        teamID: TEAM_ID,
        uploadBitcode: false,
        uploadSymbols: true
      },
      xcargs: xcargs
    )

    upload_to_testflight_with_retry(api_key, "macOS Build #{BUILD_NUMBER} - Standalone + AUv3 Plugins")
  end

  # ---------------------------------------------------------------------------
  # Build Only (No Upload)
  # ---------------------------------------------------------------------------
  desc "Just build macOS without signing"
  lane :build_only do
    UI.header "Building macOS (no signing)"
    build_app(
      project: "Echoelmusic.xcodeproj",
      scheme: "Echoelmusic-macOS",
      configuration: "Release",
      clean: false,
      skip_codesigning: true,
      skip_archive: true,
      derived_data_path: "./build/DerivedData"
    )
  end

  # ---------------------------------------------------------------------------
  # Tests
  # ---------------------------------------------------------------------------
  desc "Run macOS tests"
  lane :test do
    UI.header "Running macOS tests"
    run_tests(
      project: "Echoelmusic.xcodeproj",
      scheme: "Echoelmusic-macOS",
      clean: false,
      derived_data_path: "./build/DerivedData"
    )
  end
end

# =============================================================================
# UNIVERSAL LANE - ALL PLATFORMS
# =============================================================================

desc "Build and upload ALL platforms to TestFlight"
lane :beta_all do
  UI.header "Building ALL Platforms for TestFlight"
  UI.message("This will build: iOS, macOS, watchOS, tvOS, visionOS")

  # iOS family
  Fastlane::LaneManager.cruise_lane("ios", "beta")
  Fastlane::LaneManager.cruise_lane("ios", "beta_watchos")
  Fastlane::LaneManager.cruise_lane("ios", "beta_tvos")
  Fastlane::LaneManager.cruise_lane("ios", "beta_visionos")

  # macOS
  Fastlane::LaneManager.cruise_lane("mac", "beta")

  UI.success("")
  UI.success("=" * 60)
  UI.success("  ALL PLATFORMS UPLOADED TO TESTFLIGHT!")
  UI.success("=" * 60)
  UI.success("")
  UI.success("  Unified Bundle ID: com.echoelmusic.app")
  UI.success("  (Universal Purchase enabled across all platforms)")
  UI.success("")
  UI.success("  iOS:      com.echoelmusic.app (standalone + integrated AUv3)")
  UI.success("  macOS:    com.echoelmusic.app (standalone + embedded AUv3)")
  UI.success("  watchOS:  com.echoelmusic.app.watchkitapp")
  UI.success("  tvOS:     com.echoelmusic.app")
  UI.success("  visionOS: com.echoelmusic.app")
  UI.success("")
  UI.success("Check App Store Connect for build processing status.")
  UI.success("=" * 60)
end
