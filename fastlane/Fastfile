default_platform(:ios)

# =============================================================================
# ECHOELMUSIC - FASTLANE CONFIGURATION
# Version: 1.2.0 - Phase 10000 ULTIMATE MODE
# =============================================================================

platform :ios do
  desc "Build and upload to TestFlight (optimized for CI/CD)"
  lane :beta do
    UI.header "Starting TestFlight build for Echoelmusic v1.2.0"
    # Ensure we have the required environment variables
    UI.user_error!("ASC_KEY_ID not set") unless ENV["ASC_KEY_ID"]
    UI.user_error!("ASC_ISSUER_ID not set") unless ENV["ASC_ISSUER_ID"]
    UI.user_error!("ASC_KEY_CONTENT not set") unless ENV["ASC_KEY_CONTENT"]
    UI.user_error!("APPLE_TEAM_ID not set") unless ENV["APPLE_TEAM_ID"]

    # Setup App Store Connect API Key
    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: ENV["ASC_KEY_CONTENT"],
      is_key_content_base64: false,
      in_house: false
    )

    # Write API key to file for xcodebuild authentication
    key_path = "#{Dir.tmpdir}/AuthKey_#{ENV["ASC_KEY_ID"]}.p8"
    File.write(key_path, ENV["ASC_KEY_CONTENT"])

    # Use CI keychain if available, otherwise use default
    keychain_path = ENV["KEYCHAIN_PATH"] || "~/Library/Keychains/login.keychain-db"
    keychain_password = ENV["KEYCHAIN_PASSWORD"] || ""

    UI.message("Using keychain: #{keychain_path}")

    # === Certificate Management (only cleanup expired/excess) ===
    UI.message("üîê Checking Distribution certificates...")

    begin
      require 'spaceship'
      Spaceship::ConnectAPI.token = Spaceship::ConnectAPI::Token.create(
        key_id: ENV["ASC_KEY_ID"],
        issuer_id: ENV["ASC_ISSUER_ID"],
        key: ENV["ASC_KEY_CONTENT"]
      )

      # Find all distribution certificates
      all_certs = Spaceship::ConnectAPI::Certificate.all.select do |cert|
        cert.certificate_type == "DISTRIBUTION" || cert.certificate_type == "IOS_DISTRIBUTION"
      end

      UI.message("Found #{all_certs.count} distribution certificate(s)")

      # Only revoke expired certificates, keep valid ones
      if all_certs.count > 2
        # Keep the 2 newest, revoke the rest (Apple allows max 3)
        sorted = all_certs.sort_by { |c| c.expiration_date }.reverse
        to_revoke = sorted[2..-1]

        to_revoke.each do |cert|
          UI.message("üóëÔ∏è  Revoking old certificate: #{cert.id} (expires: #{cert.expiration_date})")
          cert.delete!
        end
        UI.success("‚úÖ Cleaned up #{to_revoke.count} old certificate(s)")
      else
        UI.success("‚úÖ Certificate count OK (#{all_certs.count}/3)")
      end
    rescue => e
      UI.important("‚ö†Ô∏è  Certificate check skipped: #{e.message}")
      UI.important("Continuing with existing certificates...")
    end

    # Get certificates - now should work since we cleaned up
    get_certificates(
      api_key: api_key,
      platform: "ios",
      keychain_path: keychain_path,
      keychain_password: keychain_password
    )

    # Fetch provisioning profile - only force refresh if CLEAN_BUILD requested
    # This enables caching for faster incremental builds while allowing
    # full refresh when needed (e.g., after cert rotation)
    get_provisioning_profile(
      api_key: api_key,
      app_identifier: "com.echoelmusic.app",
      platform: "ios",
      force: ENV["CLEAN_BUILD"] == "true" || ENV["FORCE_PROFILE_REFRESH"] == "true"
    )

    # Get the profile name that was just created/fetched
    profile_name = lane_context[SharedValues::SIGH_NAME]
    profile_uuid = lane_context[SharedValues::SIGH_UUID]

    UI.message("Using provisioning profile: #{profile_name} (#{profile_uuid})")

    # Build the app with MANUAL signing using the fetched certificate and profile
    # Optimized for faster CI/CD builds
    build_app(
      project: "Echoelmusic.xcodeproj",
      scheme: "Echoelmusic",
      configuration: "Release",
      clean: ENV["CLEAN_BUILD"] == "true",  # Only clean when explicitly requested
      export_method: "app-store",
      codesigning_identity: "Apple Distribution",
      derived_data_path: "./build/DerivedData",  # Cache for faster incremental builds
      xcargs: [
        "DEVELOPMENT_TEAM='#{ENV["APPLE_TEAM_ID"]}'",
        "CODE_SIGN_STYLE='Manual'",
        "CODE_SIGN_IDENTITY='Apple Distribution'",
        "PROVISIONING_PROFILE_SPECIFIER='#{profile_name}'",
        "COMPILER_INDEX_STORE_ENABLE=NO",  # Faster builds
        "DEBUG_INFORMATION_FORMAT='dwarf-with-dsym'"  # Required for crash reporting
      ].join(" ")
    )

    # Upload to TestFlight with optimized settings
    UI.message("üì§ Uploading to TestFlight...")
    upload_to_testflight(
      api_key: api_key,
      skip_waiting_for_build_processing: true,
      distribute_external: false,  # Don't auto-distribute to external testers
      notify_external_testers: false,
      changelog: "Build #{ENV['BUILD_NUMBER'] || 'dev'} - Phase 10000 ULTIMATE MODE",
      reject_build_waiting_for_review: false
    )

    UI.success("üéâ Successfully uploaded to TestFlight!")
    UI.success("üì± Check App Store Connect for build processing status")
  end

  desc "Just build without signing (for CI testing)"
  lane :build_only do
    UI.header "Building for simulator (no signing)"
    build_app(
      project: "Echoelmusic.xcodeproj",
      scheme: "Echoelmusic",
      configuration: "Release",
      clean: false,
      skip_codesigning: true,
      skip_archive: true,
      destination: "generic/platform=iOS Simulator",
      derived_data_path: "./build/DerivedData"
    )
  end

  desc "Run tests"
  lane :test do
    UI.header "Running tests"
    run_tests(
      project: "Echoelmusic.xcodeproj",
      scheme: "Echoelmusic",
      device: "iPhone 15 Pro",
      clean: false,
      derived_data_path: "./build/DerivedData"
    )
  end

  desc "Increment build number"
  lane :bump do
    increment_build_number(
      build_number: ENV["BUILD_NUMBER"] || (latest_testflight_build_number + 1).to_s
    )
  end

  # =============================================================================
  # SCREENSHOT AUTOMATION - Phase 10000 ULTIMATE MODE
  # =============================================================================

  desc "Capture screenshots for all devices and languages"
  lane :screenshots do
    UI.header "üì∏ Capturing App Store Screenshots"

    capture_screenshots(
      scheme: "EchoelmusicScreenshots",
      output_directory: "./fastlane/screenshots",
      clear_previous_screenshots: true,
      concurrent_simulators: true,
      languages: [
        "en-US",
        "de-DE",
        "ja",
        "es-ES",
        "fr-FR",
        "zh-Hans",
        "ko",
        "pt-BR",
        "it",
        "ru",
        "ar",
        "hi"
      ],
      devices: [
        "iPhone 16 Pro Max",
        "iPhone 16 Pro",
        "iPhone SE (3rd generation)",
        "iPad Pro 13-inch (M4)",
        "iPad Pro 11-inch (M4)"
      ],
      dark_mode: false,
      override_status_bar: true,
      reinstall_app: false,
      stop_after_first_error: false,
      derived_data_path: "./build/DerivedData"
    )

    UI.success("‚úÖ Screenshots captured successfully!")
  end

  desc "Capture screenshots for iPhone only (faster)"
  lane :screenshots_iphone do
    UI.header "üì± Capturing iPhone Screenshots"

    capture_screenshots(
      scheme: "EchoelmusicScreenshots",
      output_directory: "./fastlane/screenshots",
      clear_previous_screenshots: true,
      concurrent_simulators: true,
      languages: ["en-US"],
      devices: [
        "iPhone 16 Pro Max",
        "iPhone 16 Pro"
      ],
      dark_mode: false,
      override_status_bar: true,
      derived_data_path: "./build/DerivedData"
    )

    UI.success("‚úÖ iPhone screenshots captured!")
  end

  desc "Capture screenshots for iPad only"
  lane :screenshots_ipad do
    UI.header "üì± Capturing iPad Screenshots"

    capture_screenshots(
      scheme: "EchoelmusicScreenshots",
      output_directory: "./fastlane/screenshots",
      clear_previous_screenshots: true,
      concurrent_simulators: true,
      languages: ["en-US"],
      devices: [
        "iPad Pro 13-inch (M4)",
        "iPad Pro 11-inch (M4)"
      ],
      dark_mode: false,
      override_status_bar: true,
      derived_data_path: "./build/DerivedData"
    )

    UI.success("‚úÖ iPad screenshots captured!")
  end

  desc "Add device frames to screenshots"
  lane :frame_screenshots do
    UI.header "üñºÔ∏è Framing Screenshots"

    frameit(
      path: "./fastlane/screenshots",
      white: false,
      force_device_type: nil,
      use_platform: "IOS",
      show_complete_frame: true
    )

    UI.success("‚úÖ Screenshots framed!")
  end

  desc "Upload screenshots to App Store Connect"
  lane :upload_screenshots do
    UI.header "üì§ Uploading Screenshots to App Store Connect"

    UI.user_error!("ASC_KEY_ID not set") unless ENV["ASC_KEY_ID"]
    UI.user_error!("ASC_ISSUER_ID not set") unless ENV["ASC_ISSUER_ID"]
    UI.user_error!("ASC_KEY_CONTENT not set") unless ENV["ASC_KEY_CONTENT"]

    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: ENV["ASC_KEY_CONTENT"],
      is_key_content_base64: false
    )

    deliver(
      api_key: api_key,
      skip_binary_upload: true,
      skip_metadata: true,
      skip_app_version_update: true,
      screenshots_path: "./fastlane/screenshots",
      overwrite_screenshots: true,
      force: true
    )

    UI.success("‚úÖ Screenshots uploaded to App Store Connect!")
  end

  desc "Full screenshot workflow: capture, frame, upload"
  lane :screenshots_full do
    UI.header "üöÄ Full Screenshot Workflow"

    screenshots
    frame_screenshots
    upload_screenshots

    UI.success("üéâ Full screenshot workflow complete!")
  end
end
