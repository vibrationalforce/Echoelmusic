[
  {
    "title": "üîí P0: Encryption keys stored in UserDefaults instead of Keychain",
    "body": "## Security Issue\n\n**Severity**: P0 (Critical)\n**Category**: Secret Management\n**CVSS Score**: 8.1 (High)\n**File**: `Sources/Echoelmusic/Privacy/PrivacyManager.swift:199-207`\n\n## Description\n\nAES-256 encryption keys are currently stored in `UserDefaults`, which is NOT secure storage on iOS. UserDefaults data can be accessed:\n- By jailbroken devices\n- Through iTunes/Finder backups\n- By malware with file system access\n\nEncryption keys MUST be stored in iOS Keychain, which provides hardware-backed secure storage.\n\n## Risk\n\n- **Data Exposure**: If encryption key is compromised, all encrypted biometric data can be decrypted\n- **HIPAA Violation**: Health data must be protected with industry-standard key management\n- **App Store Rejection**: Apple may reject apps with poor security practices\n\n## Reproduction\n\n```swift\n// Current (INSECURE) implementation:\nprivate func saveKeyToKeychain(_ key: SymmetricKey) {\n    UserDefaults.standard.set(key.withUnsafeBytes { Data($0) }, forKey: \"encryptionKey\")  // ‚ùå\n}\n```\n\n## Fix\n\nUse iOS Keychain API:\n\n```swift\nprivate func saveKeyToKeychain(_ key: SymmetricKey) {\n    let keyData = key.withUnsafeBytes { Data($0) }\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrAccount as String: \"com.echoelmusic.encryption.key\",\n        kSecValueData as String: keyData,\n        kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly\n    ]\n    SecItemDelete(query as CFDictionary)\n    SecItemAdd(query as CFDictionary, nil)\n}\n```\n\n## Patch\n\nSee: `patches/ISSUE-SEC-001-biometric-websocket-encryption.diff`\n\n## References\n\n- Apple Keychain Services: https://developer.apple.com/documentation/security/keychain_services\n- OWASP Mobile Top 10: M2 - Insecure Data Storage\n- HIPAA Security Rule: 164.312(a)(2)(iv) - Encryption",
    "labels": ["security", "P0", "HIPAA", "encryption"],
    "assignees": []
  },
  {
    "title": "üîí P0: CloudKit sync transmits session data in plaintext",
    "body": "## Security Issue\n\n**Severity**: P0 (Critical)\n**Category**: Data in Transit\n**CVSS Score**: 7.5 (High)\n**File**: `Sources/Echoelmusic/Cloud/CloudSyncManager.swift:54-65`\n\n## Description\n\nSession data containing biometric information (HRV, coherence scores) is saved to CloudKit WITHOUT end-to-end encryption. While CloudKit uses TLS in transit, Apple employees and law enforcement can access data stored in plaintext.\n\n## Risk\n\n- **Privacy Violation**: Biometric data exposed to Apple/third parties\n- **GDPR Non-Compliance**: Article 32 requires encryption of personal data\n- **HIPAA Violation**: Protected Health Information (PHI) must be encrypted at rest\n- **User Trust**: Users expect biometric data to be private\n\n## Current Code\n\n```swift\nfunc saveSession(_ session: Session) async throws {\n    let record = CKRecord(recordType: \"Session\")\n    record[\"name\"] = session.name as CKRecordValue\n    record[\"avgHRV\"] = session.avgHRV as CKRecordValue  // ‚ùå Plaintext\n    record[\"avgCoherence\"] = session.avgCoherence as CKRecordValue  // ‚ùå Plaintext\n    try await privateDatabase.save(record)\n}\n```\n\n## Fix\n\nImplement E2E encryption:\n\n```swift\nfunc saveSession(_ session: Session) async throws {\n    let sessionData = try JSONEncoder().encode(session)\n    let encrypted = try privacyManager.encrypt(data: sessionData)  // ‚úÖ AES-256\n\n    let record = CKRecord(recordType: \"Session\")\n    record[\"encryptedData\"] = encrypted as CKRecordValue  // ‚úÖ Encrypted blob\n    try await privateDatabase.save(record)\n}\n```\n\n## Patch\n\nSee: `patches/ISSUE-SEC-002-cloudkit-e2e-encryption.diff`\n\n## References\n\n- GDPR Article 32: Security of processing\n- HIPAA ¬ß 164.312(e)(1): Transmission security\n- Apple CryptoKit: https://developer.apple.com/documentation/cryptokit",
    "labels": ["security", "P0", "GDPR", "HIPAA", "cloud-sync"],
    "assignees": []
  },
  {
    "title": "üîí P0: RTMP stream keys stored in plaintext",
    "body": "## Security Issue\n\n**Severity**: P0 (Critical)\n**Category**: Secret Management\n**CVSS Score**: 6.5 (Medium-High)\n**File**: `Sources/Echoelmusic/Stream/RTMPClient.swift:9`\n\n## Description\n\nRTMP stream keys for Twitch, YouTube, and other platforms are stored as plaintext `String` properties. If an attacker gains access to device memory or backups, they can:\n- Stream to the user's channel\n- Delete past streams\n- Access subscriber data\n- Impersonate the user\n\n## Risk\n\n- **Account Takeover**: Attacker can stream to user's channels\n- **Reputation Damage**: Malicious content streamed to audience\n- **Financial Loss**: Banned accounts, lost subscribers\n- **Privacy**: Access to channel analytics, subscriber info\n\n## Current Code\n\n```swift\nclass RTMPClient {\n    private let streamKey: String  // ‚ùå Plaintext in memory\n\n    init(url: String, streamKey: String, port: Int = 1935) {\n        self.streamKey = streamKey  // ‚ùå Stored in class property\n    }\n}\n```\n\n## Fix\n\nStore in Keychain, load only when needed:\n\n```swift\nclass RTMPClient {\n    private let streamKeyIdentifier: String  // Just identifier\n\n    static func saveStreamKey(_ key: String, for platform: String) throws {\n        // Save to Keychain with kSecAttrAccessibleWhenUnlockedThisDeviceOnly\n    }\n\n    private func loadStreamKey() throws -> String {\n        // Load from Keychain only when connecting\n    }\n}\n```\n\n## Patch\n\nSee: `patches/ISSUE-SEC-003-rtmp-stream-key-security.diff`\n\n## Additional Measures\n\n1. Never log stream keys (even in debug mode)\n2. Clear from memory after use\n3. Use separate keys for dev/prod\n4. Implement key rotation\n5. Rate limit connection attempts\n\n## References\n\n- OWASP M2: Insecure Data Storage\n- CWE-312: Cleartext Storage of Sensitive Information",
    "labels": ["security", "P0", "streaming", "secrets"],
    "assignees": []
  },
  {
    "title": "‚ö° P1: Audio latency exceeds 3ms target",
    "body": "## Performance Issue\n\n**Severity**: P1 (High)\n**Category**: Audio Performance\n**Target**: <3ms roundtrip latency\n**Current**: ~5-8ms (estimated)\n**File**: Multiple audio processing files\n\n## Description\n\nReal-time biofeedback requires <3ms audio latency for seamless user experience. Current implementation may have:\n- Large buffer sizes\n- Allocations in audio callback\n- Unoptimized DSP algorithms\n- Lock contention\n\n## Impact\n\n- **User Experience**: Noticeable delay between voice and processed audio\n- **Biofeedback**: HRV changes not reflected in real-time\n- **Professional Use**: Unusable for live performance\n\n## Profiling Required\n\n```swift\n// Add to audio callback:\nimport juce_audio_processors\n\nvoid processBlock(AudioBuffer<float>& buffer, MidiBuffer&) {\n    ScopedNoDenormals noDenormals;\n    auto perfCounter = PerformanceCounter(__FUNCTION__);\n\n    // Your processing...\n\n    if (perfCounter.getMilliseconds() > 3.0) {\n        DBG(\"Audio callback too slow: \" << perfCounter.getMilliseconds() << \"ms\");\n    }\n}\n```\n\n## Optimization Checklist\n\n- [ ] Profile with Instruments > Audio\n- [ ] Remove allocations from audio callback\n- [ ] Use lock-free structures (no mutex)\n- [ ] Apply SIMD optimizations (vDSP, Accelerate)\n- [ ] Reduce buffer size to 128-256 samples\n- [ ] Pre-calculate expensive math (sin, cos, sqrt)\n- [ ] Enable denormal protection\n\n## Benchmarks\n\nCreate performance tests:\n\n```swift\nfunc testAudioCallbackLatency() {\n    measure {\n        // Process 1000 audio blocks\n        // Assert average < 3ms\n    }\n}\n```\n\n## References\n\n- `/CLAUDE.md` - Performance targets\n- `.claude/commands/performance-fix.md` - Profiling guide",
    "labels": ["performance", "P1", "audio", "latency"],
    "assignees": []
  },
  {
    "title": "üß™ P1: Test coverage at 40% (target: >80%)",
    "body": "## Quality Issue\n\n**Severity**: P1 (High)\n**Category**: Testing\n**Current Coverage**: ~40%\n**Target Coverage**: >80%\n\n## Description\n\n**Test Files**: 6 files, ~1,650 lines of tests\n**Source Code**: 110 files, ~40,197 lines of code\n**Test Ratio**: 1:24 (tests:source)\n\nCritical paths lack test coverage:\n- Audio processing algorithms\n- Biometric data encryption\n- Cloud sync E2E encryption\n- RTMP streaming\n- Particle engine physics\n- HRV coherence calculation\n\n## Missing Test Categories\n\n### Unit Tests Needed\n\n- [ ] Audio DSP effects (50+ processors)\n- [ ] Spatial audio positioning\n- [ ] MIDI 2.0 handling\n- [ ] Video chromakey algorithm\n- [ ] Encryption/decryption roundtrip\n- [ ] Keychain storage/retrieval\n- [ ] Stream key management\n\n### Integration Tests Needed\n\n- [ ] HealthKit ‚Üí Audio parameter mapping\n- [ ] Cloud sync E2E (save ‚Üí fetch ‚Üí decrypt)\n- [ ] Multi-platform streaming\n- [ ] RTMP handshake\n- [ ] Session recording ‚Üí export\n\n### Performance Tests\n\n- [ ] Audio latency <3ms\n- [ ] Particle engine 60 FPS\n- [ ] HRV calculation <10ms\n- [ ] Memory usage <200MB\n\n### Security Tests\n\n- [ ] Encryption key never in UserDefaults\n- [ ] Biometric data never logged\n- [ ] Stream keys never in plaintext\n- [ ] HTTPS-only network requests\n\n## CI/CD Integration\n\nUpdate `.github/workflows/ci.yml`:\n\n```yaml\n- name: Run Tests with Coverage\n  run: |\n    xcodebuild test \\\n      -scheme Echoelmusic \\\n      -destination 'platform=iOS Simulator,name=iPhone 15 Pro' \\\n      -enableCodeCoverage YES\n\n- name: Check Coverage Threshold\n  run: |\n    xcrun xccov view --report xcodebuild.xcresult | \\\n    awk '/^Total/ {if ($2 < 80.0) exit 1}'\n```\n\n## Test Utilities\n\nCreate mock objects:\n\n```swift\nclass MockHealthKitManager: HealthKitManager {\n    var mockHRV: Double = 75.0\n    var mockHeartRate: Double = 65.0\n}\n\nclass MockPrivacyManager: PrivacyManager {\n    func encrypt(data: Data) throws -> Data {\n        return data  // Passthrough for tests\n    }\n}\n```\n\n## Priority Order\n\n1. **P0**: Security tests (encryption, Keychain)\n2. **P1**: Audio processing tests (latency, quality)\n3. **P1**: Biofeedback tests (HRV, coherence)\n4. **P2**: UI tests (particle engine, visual rendering)\n\n## References\n\n- XCTest: https://developer.apple.com/documentation/xctest\n- Code Coverage: https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/07-code_coverage.html",
    "labels": ["testing", "P1", "quality", "ci-cd"],
    "assignees": []
  },
  {
    "title": "üìä P2: Particle engine limited to 500 particles (target: 100k)",
    "body": "## Performance Issue\n\n**Severity**: P2 (Medium)\n**Category**: Visual Performance\n**Current**: Max 500 particles @ 60fps\n**Target**: 100k particles @ 60fps\n**File**: `Sources/Echoelmusic/ParticleView.swift:39`\n\n## Description\n\nThe current particle system is CPU-bound and limited to 500 particles. For immersive visual experiences, we need to support 100k+ particles using GPU compute shaders.\n\n## Current Implementation\n\n```swift\nprivate var targetParticleCount: Int {\n    let minCount = 10\n    let maxCount = 500  // ‚ùå Limited\n    let range = maxCount - minCount\n    return minCount + Int(Float(range) * audioLevel)\n}\n```\n\n## Optimization Strategies\n\n### 1. GPU Compute Shaders (Metal)\n\n```metal\n// ParticleUpdate.metal\nkernel void updateParticles(\n    device Particle* particles [[buffer(0)]],\n    device PhysicsParams& params [[buffer(1)]],\n    uint id [[thread_position_in_grid]]\n) {\n    Particle p = particles[id];\n\n    // Update position/velocity on GPU (parallel)\n    p.position += p.velocity * params.deltaTime;\n    p.velocity += params.gravity * params.deltaTime;\n\n    particles[id] = p;\n}\n```\n\n### 2. Spatial Partitioning\n\n```swift\n// Grid-based collision detection: O(n¬≤) ‚Üí O(n)\nclass ParticleGrid {\n    var cells: [[Particle]] = []\n\n    func update() {\n        for cell in cells {\n            // Only check collisions within same cell\n        }\n    }\n}\n```\n\n### 3. Instanced Rendering\n\n```swift\n// Render all particles in single draw call\nfunc renderParticles(encoder: MTLRenderCommandEncoder) {\n    encoder.drawPrimitives(\n        type: .point,\n        vertexStart: 0,\n        vertexCount: particleCount,\n        instanceCount: 1\n    )\n}\n```\n\n## Benchmarks Required\n\n| Particle Count | CPU (Current) | GPU (Target) |\n|----------------|---------------|---------------|\n| 1,000          | 60 FPS        | 60 FPS       |\n| 10,000         | 30 FPS        | 60 FPS       |\n| 100,000        | 5 FPS         | 60 FPS       |\n\n## Implementation Plan\n\n1. Create Metal compute shader for particle update\n2. Move physics to GPU\n3. Implement instanced rendering\n4. Add LOD (reduce detail for distant particles)\n5. Profile with Instruments > GPU\n6. Optimize memory access patterns\n\n## References\n\n- Metal Compute: https://developer.apple.com/metal/\n- `.claude/commands/performance-fix.md`\n- Instruments GPU Profiler",
    "labels": ["performance", "P2", "visual", "metal", "gpu"],
    "assignees": []
  },
  {
    "title": "‚ö†Ô∏è P2: RTMP handshake incomplete (TODO in code)",
    "body": "## Implementation Gap\n\n**Severity**: P2 (Medium)\n**Category**: Streaming\n**File**: `Sources/Echoelmusic/Stream/RTMPClient.swift:79-83`\n\n## Description\n\nThe RTMP streaming implementation has a placeholder handshake. Full RTMP handshake is required for compatibility with all streaming platforms.\n\n## Current Code\n\n```swift\nprivate func performHandshake() async throws {\n    // TODO: Implement RTMP handshake (C0, C1, C2)\n    // Placeholder for now\n    print(\"ü§ù RTMPClient: Handshake completed\")\n}\n```\n\n## RTMP Handshake Protocol\n\n1. **C0/S0**: Version negotiation (1 byte)\n2. **C1/S1**: Random data + timestamp (1536 bytes)\n3. **C2/S2**: Echo of peer's handshake (1536 bytes)\n\nAfter handshake, send `connect()`, `createStream()`, `publish()` commands.\n\n## Implementation\n\n```swift\nprivate func performHandshake() async throws {\n    // C0: Send version byte\n    let c0 = Data([0x03])  // RTMP version 3\n    try await send(c0)\n\n    // C1: Send timestamp + random data\n    var c1 = Data(count: 1536)\n    // ... fill with timestamp + random bytes\n    try await send(c1)\n\n    // S0: Receive server version\n    let s0 = try await receive(count: 1)\n    guard s0[0] == 0x03 else {\n        throw RTMPError.handshakeFailed\n    }\n\n    // S1: Receive server handshake\n    let s1 = try await receive(count: 1536)\n\n    // C2: Echo server's S1\n    try await send(s1)\n\n    // S2: Receive echo of our C1\n    let s2 = try await receive(count: 1536)\n    guard s2 == c1 else {\n        throw RTMPError.handshakeFailed\n    }\n\n    print(\"ü§ù RTMP handshake complete\")\n}\n```\n\n## Testing\n\n- Test with Twitch RTMP server\n- Test with YouTube RTMP server\n- Test with custom NGINX RTMP\n- Verify compatibility with all platforms\n\n## References\n\n- RTMP Specification: https://rtmp.veriskope.com/docs/spec/\n- `.claude/commands/streaming-platform.md`",
    "labels": ["streaming", "P2", "implementation", "rtmp"],
    "assignees": []
  },
  {
    "title": "üìù P3: Smart contracts mentioned in docs but not implemented",
    "body": "## Documentation/Code Mismatch\n\n**Severity**: P3 (Low)\n**Category**: Documentation\n\n## Description\n\nThe original audit request mentions smart contracts and NFT features, but:\n- No `.sol` files found in repository\n- No `smart-contracts/` directory\n- No blockchain integration\n- No Web3 dependencies\n\nThis suggests either:\n1. Feature was planned but not implemented\n2. Feature was removed during rebranding\n3. Documentation is outdated\n\n## Recommendation\n\nUpdate documentation to reflect current state:\n\n### Option 1: Remove NFT/Blockchain References\n\nIf not planned:\n- Remove from COMPLETE_FEATURE_LIST.md\n- Remove from ARCHITECTURE.md\n- Update README.md\n\n### Option 2: Add to Roadmap\n\nIf planned for future:\n- Add to Phase 5 or Phase 6\n- Create design doc: `docs/blockchain-integration.md`\n- Outline use cases:\n  - Biometric NFTs (emotion peak moments)\n  - Session ownership on-chain\n  - Royalty distribution\n  - Creator marketplace\n\n## If Implementing\n\nUse `.claude/commands/smart-contract-feature.md` for guidance:\n- Solidity ^0.8.19\n- OpenZeppelin contracts\n- Hardhat for testing\n- Polygon/Ethereum deployment\n- 100% test coverage\n\n## No Action Required\n\nThis is a documentation cleanup issue only. No security or functionality impact.",
    "labels": ["documentation", "P3", "blockchain"],
    "assignees": []
  }
]
